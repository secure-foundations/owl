// Losely following a simple example of TLS 1.3 handshake: tls13.xargs.org

locality client
locality server

name client_data : nonce @ client
name client_random : nonce @ client
name client_dh_sk : DH @ client

name server_data : nonce @ server
name server_random : nonce @ server
name server_dh_sk : DH @ server

// ClientRandom and ServerRandom in the hello messages are public
corr adv ==> [client_random]
corr adv ==> [server_random]

// Highly simplified version of TLS ClientHello
// TODO: cipher suite negotiation, extensions, etc.
struct client_hello {
    client_hello_random: Name(client_random),
    client_hello_pk: dhpk(client_dh_sk)
}

// Highly simplified version of TLS ServerHello
struct server_hello {
    server_hello_random: Name(server_random),
    server_hello_pk: dhpk(server_dh_sk)
}

// TODO: X.509 certificate simplified to a signing key
name server_cert_key : sigkey dhpk(server_dh_sk) @ server
corr [server_cert_key] ==> [server_dh_sk] /\ [client_dh_sk] // TODO: is this correct?

// Merged version of Server Certificate and Certificate Verify
struct server_certificate {
    server_certificate_cert: vk(server_cert_key),
    server_certificate_signature: Data<adv> ||signature||
}

counter client_application_traffic_counter @ client
counter server_application_traffic_counter @ server

// TODO: change to AEAD
nametype client_handshake_traffic_key_t = nonce
nametype server_handshake_traffic_key_t = enckey server_certificate

nametype client_application_traffic_key_t = st_aead Name(client_data)
    aad x. true // TODO: header
    nonce client_application_traffic_counter // TODO: xor with client_write_iv

nametype server_application_traffic_key_t = st_aead Name(server_data)
    aad x. true // TODO: header
    nonce server_application_traffic_counter // TODO: xor with server_write_iv

// Some constant labels (Section 7.1)
func const_tls13_() = 0x746c73313320
func const_derived() = 0x64657269766564
func const_c_hs_traffic() = 0x632068732074726166666963
func const_s_hs_traffic() = 0x732068732074726166666963
func const_c_ap_traffic() = 0x632061702074726166666963
func const_s_ap_traffic() = 0x732061702074726166666963

// TODO: add context (hash of previous messages)
//Ssee Section 7.1
func kdf_label_info(lbl) = const_tls13_() ++ lbl

odh early_secret : client_dh_sk, server_dh_sk -> {salt info.
    // client_handshake_traffic_secret
    // TODO: I'm conflating client_handshake_traffic_secret and client_write_key here
    // since the latter is derived from the former via another HKDF-Expand call
    info == kdf_label_info(const_c_hs_traffic()) -> strict client_handshake_traffic_key_t, // TODO: ClientHandshakeFinished

    // server_handshake_traffic_secret
    info == kdf_label_info(const_s_hs_traffic()) -> strict server_handshake_traffic_key_t,

    // Master Secret
    info == kdf_label_info(const_derived()) -> strict kdf {ikm info.
        // client_application_traffic_secret_0
        info == kdf_label_info(const_c_ap_traffic()) -> strict client_application_traffic_key_t,

        // server_application_traffic_secret_0
        info == kdf_label_info(const_s_ap_traffic()) -> strict server_application_traffic_key_t
    }
}

// We don't support PSK yet
// TODO: should we pad it to a certain length?
func psk() = 0x00

func early_secret_derived_ghost() = gkdf<nonce;0>(0x00, psk(), kdf_label_info(const_c_hs_traffic()))
func dh_shared_secret() = dh_combine(dhpk(get(client_dh_sk)), get(server_dh_sk))

// Resulting secrets from the handshake
struct handshake_result {
    client_handshake_traffic_secret:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(KDF<nonce;0;client_handshake_traffic_key_t>(
                early_secret_derived_ghost(),
                dh_shared_secret(),
                kdf_label_info(const_c_hs_traffic())))
        else
            Data<adv>,

    server_handshake_traffic_secret:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(KDF<enckey;0;server_handshake_traffic_key_t>(
                early_secret_derived_ghost(),
                dh_shared_secret(),
                kdf_label_info(const_s_hs_traffic())))
        else
            Data<adv>,

    client_application_traffic_secret_0:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(KDF<enckey;0;client_application_traffic_key_t>(
                gkdf<kdfkey;0>(
                    early_secret_derived_ghost(),
                    dh_shared_secret(),
                    kdf_label_info(const_derived())),
                dh_shared_secret(),
                kdf_label_info(const_c_ap_traffic())))
        else
            Data<adv>,

    server_application_traffic_secret_0:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(KDF<enckey;0;server_application_traffic_key_t>(
                gkdf<kdfkey;0>(
                    early_secret_derived_ghost(),
                    dh_shared_secret(),
                    kdf_label_info(const_derived())),
                dh_shared_secret(),
                kdf_label_info(const_s_ap_traffic())))
        else
            Data<adv>
}

// client_hello is given has argument since we don't
// know if client_dh_sk <= adv
def server_handshake(msg: client_hello) @ server : Option(handshake_result)
    =
    // input msg in
    parse msg as client_hello(_, client_dh_pk) in
        let server_hello = server_hello(get(server_random), dhpk(get(server_dh_sk))) in
        let _ = output server_hello to endpoint(client) in
        let sk = dh_combine(client_dh_pk, get(server_dh_sk)) in

        corr_case client_dh_sk in
        corr_case server_dh_sk in

        // Key schedule in Section 7.1
        let early_secret_derived = kdf<0;;nonce;0>(0x00, psk(), kdf_label_info(const_c_hs_traffic())) in
        let client_handshake_traffic_secret = kdf<;odh early_secret[0];nonce;0>(
            early_secret_derived, sk, kdf_label_info(const_c_hs_traffic())) in
        let server_handshake_traffic_secret = kdf<;odh early_secret[1];enckey;0>(
            early_secret_derived, sk, kdf_label_info(const_s_hs_traffic())) in

        let handshake_secret_derived = kdf<;odh early_secret[2];kdfkey;0>(
            early_secret_derived, sk, kdf_label_info(const_derived())) in

        let client_application_traffic_secret_0 = kdf<0;;enckey;0>(handshake_secret_derived, sk,
            kdf_label_info(const_c_ap_traffic())) in
        let server_application_traffic_secret_0 = kdf<1;;enckey;0>(handshake_secret_derived, sk,
            kdf_label_info(const_s_ap_traffic())) in

        // TODO: derive client/server_write_key/iv
        // by another HKDF-Expand call

        // Send certificate and certificate verify
        // TODO: this needs to sign the server_hello message instead of just the DH key
        let sig = sign(get(server_cert_key), dhpk(get(server_dh_sk))) in
        let server_certificate = server_certificate(get_vk(server_cert_key), sig) in

        // TODO: change to AEAD
        let server_certificate_enc = aenc(server_handshake_traffic_secret, server_certificate) in
        let _ = output server_certificate_enc to endpoint(client) in

        Some(handshake_result(
            client_handshake_traffic_secret,
            server_handshake_traffic_secret,
            client_application_traffic_secret_0,
            server_application_traffic_secret_0
        ))
    otherwise
        None()

def client_handshake() @ client : Option(handshake_result)
    =
    let hello = client_hello(get(client_random), dhpk(get(client_dh_sk))) in
    let _ = output hello to endpoint(server) in
    input msg in
    parse msg as server_hello(_, server_dh_pk) in
        let sk = dh_combine(server_dh_pk, get(client_dh_sk)) in

        // Same process as the server
        corr_case client_dh_sk in
        corr_case server_dh_sk in

        // TODO: prfodh
        assume(server_dh_pk == dhpk(get(server_dh_sk)));

        // Key schedule in Section 7.1
        let early_secret_derived = kdf<0;;nonce;0>(0x00, psk(), kdf_label_info(const_c_hs_traffic())) in
        let client_handshake_traffic_secret = kdf<;odh early_secret[0];nonce;0>(
            early_secret_derived, sk, kdf_label_info(const_c_hs_traffic())) in
        let server_handshake_traffic_secret = kdf<;odh early_secret[1];enckey;0>(
            early_secret_derived, sk, kdf_label_info(const_s_hs_traffic())) in

        let handshake_secret_derived = kdf<;odh early_secret[2];kdfkey;0>(
            early_secret_derived, sk, kdf_label_info(const_derived())) in

        let client_application_traffic_secret_0 = kdf<0;;enckey;0>(handshake_secret_derived, sk,
            kdf_label_info(const_c_ap_traffic())) in
        let server_application_traffic_secret_0 = kdf<1;;enckey;0>(handshake_secret_derived, sk,
            kdf_label_info(const_s_ap_traffic())) in

        input server_certificate_enc in
        case adec(server_handshake_traffic_secret, server_certificate_enc) {
            | None => None()
            | Some server_certificate =>
                parse server_certificate as server_certificate(_, sig) in
                    corr_case server_cert_key in
                    case vrfy(get_vk(server_cert_key), server_dh_pk, sig) {
                        | Some server_dh_pk_verified =>
                            Some(handshake_result(
                                client_handshake_traffic_secret,
                                server_handshake_traffic_secret,
                                client_application_traffic_secret_0,
                                server_application_traffic_secret_0
                            ))
                        | None => None()
                    }
                otherwise None()
        }
    otherwise None()
