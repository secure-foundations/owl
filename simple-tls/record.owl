// A highly simplified TLS record layer

include "defs.owl"
include "handshake.owl"

// Section 5.2, RFC 8446
struct Record {
    Record_type: Data<adv> |1|,
    Record_version: Const(0x0303),
    Record_length: Data<adv> |2|,
    Record_encrypted: Data<adv>
}

struct ServerState {
    ServerState_keys: HandshakeResult,
    ServerState_buffer: Data<adv>
}

struct NewData {
    NewData_state: ServerState,
    NewData_data:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            Name(client_data) // Should I use this here? Should it be indexed?
        else
            Data<adv>
}

enum ProcessResult {
    | ProcessResult_NoData ServerState
    | ProcessResult_NewData NewData
    | ProcessResult_Error
}

// Process incoming message on the server side
// TODO: the client side should roughly be the same
def server_process(state: ServerState) @ server : ProcessResult
    =
    parse state as ServerState(keys, buffer) in
    parse keys as HandshakeResult(_, _, client_app_key, _) in
        input msg in
        parse buffer ++ msg as Record(ctype, version, len, encrypted) in
            if geq(length(encrypted), len) then
                let encrypted = subrange(encrypted, 0, len) in

                // TODO: Need to repeatedly process messages since multiple records can arrive at once
                // which may require recursion?
                let rest = subrange(encrypted, len, minus(length(encrypted), len)) in

                if eq(ctype, CTYPE_APPLICATION_DATA()) then
                    corr_case client_dh_sk in
                    corr_case server_dh_sk in

                    let counter = get_counter client_application_traffic_counter_recv in

                    // aad is the record header
                    case st_aead_dec(client_app_key, encrypted, ctype ++ version ++ len, counter) {
                        | None => ProcessResult_Error()
                        | Some decrypted =>
                            // TODO: decrypted needs to be parsed as TLSInnerPlaintext in RFC 8446
                            inc_counter client_application_traffic_counter_recv;

                            // Check overflow
                            ProcessResult_NewData(NewData(ServerState(keys, rest), decrypted))
                    }

                else if eq(ctype, CTYPE_HANDSHAKE()) then
                    // TODO: process key updates
                    ProcessResult_NoData(ServerState(keys, rest))

                else
                    // TODO: unsupported content type
                    ProcessResult_Error()

            else
                // Not enough data
                ProcessResult_NoData(ServerState(keys, buffer ++ msg))

        otherwise
            // Append more data to wait for a complete package
            // TODO: this is assuming that the header always arrives in one piece
            ProcessResult_Error()

    // TODO: can we eliminate these cases?
    otherwise ProcessResult_Error()
    otherwise ProcessResult_Error()
