// A highly simplified TLS record layer

include "defs.owl"
include "handshake.owl"

// Section 5.2, RFC 8446
struct Record {
    Record_type: Const(0x17), // CTYPE_APPLICATION_DATA()
    Record_version: Const(0x0303),
    Record_length: Data<adv> |2|,
    Record_encrypted: Data<adv>
}

struct ServerState {
    ServerState_keys: HandshakeResult,
    ServerState_buffer: Data<adv>
}

struct ServerNewData {
    ServerNewData_state: ServerState,
    ServerNewData_data:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            Name(client_data) // Should I use this here? Should it be indexed?
        else
            Data<adv>
}

enum ServerRecvResult {
    | ServerRecvResult_NoData ServerState
    | ServerRecvResult_ServerNewData ServerNewData
    | ServerRecvResult_Error
}

// Process incoming message on the server side
// TODO: the client side should roughly be the same
def server_recv(state: ServerState) @ server : ServerRecvResult
    =
    parse state as ServerState(keys, buffer) in
    parse keys as HandshakeResult(_, _, client_app_key, client_app_iv, _, _) in
    input msg in
    parse buffer ++ msg as Record(ctype, version, len, encrypted) in
        if geq(length(encrypted), len) then
            let encrypted = subrange(encrypted, 0, len) in

            // TODO: Need to repeatedly process messages since multiple records can arrive at once
            // which may require recursion?
            let rest = subrange(encrypted, len, minus(length(encrypted), len)) in

            corr_case client_dh_sk in
            corr_case server_dh_sk in

            let counter = get_counter client_application_traffic_counter_recv in

            // aad is the record header
            case st_aead_dec(client_app_key, encrypted, ctype ++ version ++ len, xor(counter, client_app_iv)) {
                | None => ServerRecvResult_Error()
                | Some decrypted =>
                    parse decrypted as ClientInnerRecord(decrypted, ctype) in
                        // TODO: process different ctypes
                        inc_counter client_application_traffic_counter_recv;
                        ServerRecvResult_ServerNewData(ServerNewData(ServerState(keys, rest), decrypted))

                    otherwise ServerRecvResult_Error()
            }

        else
            // Not enough data
            ServerRecvResult_NoData(ServerState(keys, buffer ++ msg))

    // Append more data to wait for a complete package
    // TODO: this is assuming that the header always arrives in one piece
    otherwise ServerRecvResult_Error()

enum ClientSendResult {
    | ClientSendResult_Success
    | ClientSendResult_Error
}

// Send new message on the client side
// TODO: assume that data's length is less than 2^16
def client_send(
    keys: HandshakeResult,

    // Client data is public unless both DH secrets are secure
    // and it should be less than equal to 2^14 bytes (Section 5.1, RFC 8446)
    data: d : if sec(client_dh_sk) /\ sec(server_dh_sk) then Name(client_data) else Data<adv>
        { leq(length(d), 16384) }
) @ client : ClientSendResult
    =
    parse keys as HandshakeResult(_, _, client_app_key, client_app_iv, _, _) in
    corr_case client_dh_sk in
    corr_case server_dh_sk in

    // TODO: replace 0x0000 with the ciphertext length (how to compute it?)
    let enc_data = ClientInnerRecord(data, CTYPE_APPLICATION_DATA()) in
    let enc_len = cipherlen(length(enc_data)) in
    let encrypted = st_aead_enc<client_application_traffic_counter, pattern i. xor(i, client_app_iv)>(
        client_app_key,
        enc_data,

        // TODO: is enc_len correct? how to pad it into two bytes?
        CTYPE_APPLICATION_DATA() ++ 0x0303 ++ as_u16(enc_len)
    ) in

    let _ = output Record(CTYPE_APPLICATION_DATA(), 0x0303, length(encrypted), encrypted) to endpoint(server) in
    ClientSendResult_Success()
