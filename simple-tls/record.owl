// A highly simplified TLS record layer

include "defs.owl"
include "handshake.owl"

// Section 5.2, RFC 8446
struct Record {
    Record_type: Const(0x17), // CTYPE_APPLICATION_DATA()
    Record_version: Const(0x0303),
    Record_length: Data<adv> |2|,
    Record_encrypted: Data<adv>
}

enum ServerReadResult {
    | ServerReadResult_Data
        (if sec(client_dh_sk) /\ sec(server_dh_sk) then
            Data<adv /\ [client_data]> // Should I use this here? Should it be indexed?
        else
            Data<adv>)
    | ServerReadResult_End
    | ServerReadResult_Error
}

struct Alert {
    Alert_level: Data<adv> |1|, // "the level field can safely be ignored" in TLS 1.3
    Alert_desc: Data<adv> |1|
}

// Process incoming records on the server side
// Fragmentation is expected to be handled by the caller of this process
// TODO: the client side should roughly be the same
def server_read(
    keys: HandshakeResult,
    record: Record
) @ server : ServerReadResult
    =
    parse keys as HandshakeResult(_, _, client_app_key, client_app_iv, _, _) in
    parse record as Record(ctype, version, len, encrypted) in
        corr_case client_dh_sk in
        corr_case server_dh_sk in

        let counter = get_counter client_application_traffic_counter_recv in
        let header = ctype ++ version ++ len in

        case st_aead_dec(client_app_key, encrypted, header, xor(counter, client_app_iv)) {
            | None => ServerReadResult_Error()
            | Some decrypted =>
                parse decrypted as ClientInnerRecord(ctype, decrypted) in
                    if eq(ctype, CTYPE_APPLICATION_DATA()) then
                        // New application data
                        inc_counter client_application_traffic_counter_recv;
                        ServerReadResult_Data(decrypted)

                    else if eq(ctype, CTYPE_ALERT()) then
                        // Alert, either throw an error or indicate the end of stream
                        parse decrypted as Alert(_, desc) in
                            if eq(desc, ALERT_DESC_CLOSE_NOTIFY()) then
                                ServerReadResult_End()
                            else
                                ServerReadResult_Error()
                        otherwise ServerReadResult_Error()

                    else
                        ServerReadResult_Error()
                otherwise ServerReadResult_Error()
        }

enum ClientSendResult {
    | ClientSendResult_Success
    | ClientSendResult_Error
}

// Send new message on the client side
// TODO: assume that data's length is less than 2^16
def client_send(
    keys: HandshakeResult,

    // Client data is public unless both DH secrets are secure
    // and it should be less than equal to 2^14 bytes (Section 5.1, RFC 8446)
    data: d :
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            ClientData
        else
            Data<adv>
        { leq(length(d), 16384) }
) @ client : ClientSendResult
    =
    parse keys as HandshakeResult(_, _, client_app_key, client_app_iv, _, _) in
    corr_case client_dh_sk in
    corr_case server_dh_sk in

    // TODO: replace 0x0000 with the ciphertext length (how to compute it?)
    let enc_data = ClientInnerRecord(CTYPE_APPLICATION_DATA(), data) in
    let enc_len = cipherlen(length(enc_data)) in
    let encrypted = st_aead_enc<client_application_traffic_counter, pattern i. xor(i, client_app_iv)>(
        client_app_key,
        enc_data,

        // TODO: is enc_len correct? how to pad it into two bytes?
        CTYPE_APPLICATION_DATA() ++ 0x0303 ++ as_u16(enc_len)
    ) in

    let _ = output Record(CTYPE_APPLICATION_DATA(), 0x0303, length(encrypted), encrypted) to endpoint(server) in
    ClientSendResult_Success()
