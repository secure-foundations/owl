/**
 * Naming conventions:
 * 1. Names, odh, kdf, procedure, counter declarations use snake_case
 * 2. Structs, enums, and name types use CamelCase
 * 3. Functions use capitalized SNAKE_CASE (except for uninterpreted functions)
 * 4. Fields of a struct are named as <struct abbreviation>_<field_name>
 * 5. Local variables are snake_case
 */

locality client
locality server

// Some constant labels (Section 7.1)
func DERIVED() = "derived"
func C_E_TRAFFIC() = "c e traffic"
func C_HS_TRAFFIC() = "c hs traffic"
func S_HS_TRAFFIC() = "s hs traffic"
func C_AP_TRAFFIC() = "c ap traffic"
func S_AP_TRAFFIC() = "s ap traffic"
func KEY() = "key"
func IV() = "iv"

// ContentType's
func CTYPE_ALERT() = 0x15
func CTYPE_HANDSHAKE() = 0x16
func CTYPE_APPLICATION_DATA() = 0x17

// AlertDescription's
func ALERT_DESC_CLOSE_NOTIFY() = 0x00

// struct HKDFContext {
//     HKDFContext_len: Data<adv> |2|,
//     HKDFContext_label_pref: Const(0x746c73313320), // "tls13 "
//     HKDFContext_label: Data<adv>
//     // HKDFContext_context: Data<adv> ||crh||
// }

// TODO: make sure |crh| has the correct length (u16)
// TODO: add context (hash of previous messages)
// see Section 7.1
func KDF_LABEL(lbl) = |crh| ++ "tls13 " ++ lbl

// We don't support PSK yet
// TODO: should we pad it to a certain length?
func PSK() = 0x00
func HASH_LEN_0() = 0x00 // TODO: pad it to |crh|

// Placeholder for unsupported functions in Owl
func leq arity 2
func geq arity 2
func minus arity 2
func as_u16 arity 1
func subrange arity 3

name client_data : nonce @ client
name client_random : nonce @ client
name client_dh_sk : DH @ client

name server_data : nonce @ server
name server_random : nonce @ server
name server_dh_sk : DH @ server

func DH_SHARED_SECRET() = dh_combine(dhpk(get(client_dh_sk)), get(server_dh_sk))

// TODO: X.509 certificate simplified to a signing key
name server_cert_key : sigkey dhpk(server_dh_sk) @ server

// Highly simplified version of TLS ClientHello
// TODO: cipher suite negotiation, extensions, etc.
struct ClientHello {
    ch_random: Name(client_random),
    ch_pk: dhpk(client_dh_sk)
}

// Highly simplified version of TLS ServerHello
struct ServerHello {
    sh_random: Name(server_random),
    sh_pk: dhpk(server_dh_sk)
}

// Merged version of Server Certificate and Certificate Verify
struct ServerCertificate {
    sc_cert: vk(server_cert_key),
    sc_sig: Data<adv> ||signature||
}

// For sending
counter client_application_traffic_counter @ client
counter server_application_traffic_counter @ server

// For receiving
counter client_application_traffic_counter_recv @ server
counter server_application_traffic_counter_recv @ client

def client_send @ client
type ClientData = x : Data<adv /\ [client_data], |adv|> { happened(client_send(x)) }

struct ClientInnerRecord {
    // TODO: in the actual definition (TLSInnerPlaintext in RFC 8446)
    // this content type actually comes after content
    // but we assume that this permutation is handled in Vest
    ir_type: Data<adv> |1|,

    ir_content:
        if ir_type == CTYPE_APPLICATION_DATA() then
            ClientData
        else
            Data<adv>

    // TODO: padding handled in Vest
}

// Similar to the exec version of key derivation, but in ghost mode
// so that they can be used in types
// TODO can we remove this?
func EARLY_SECRET_DERIVED_GHOST() = gexpand<nonce;0>(gextract(HASH_LEN_0(), PSK()), KDF_LABEL(DERIVED()))

func HANDSHAKE_SECRET_GHOST() = gextract(EARLY_SECRET_DERIVED_GHOST(), DH_SHARED_SECRET())
func CLIENT_HANDSHAKE_TRAFFIC_SECRET_GHOST() = gexpand<nonce;0>(HANDSHAKE_SECRET_GHOST(), KDF_LABEL(C_HS_TRAFFIC()))
func SERVER_HANDSHAKE_TRAFFIC_SECRET_GHOST() = gexpand<enckey;0>(HANDSHAKE_SECRET_GHOST(), KDF_LABEL(S_HS_TRAFFIC()))

func MASTER_SECRET_GHOST() = gextract(gexpand<extractkey;0>(HANDSHAKE_SECRET_GHOST(), KDF_LABEL(DERIVED())), HASH_LEN_0())
func CLIENT_APPLICATION_TRAFFIC_SECRET_0_GHOST() = gexpand<expandkey;0>(MASTER_SECRET_GHOST(), KDF_LABEL(C_AP_TRAFFIC()))
func SERVER_APPLICATION_TRAFFIC_SECRET_0_GHOST() = gexpand<expandkey;0>(MASTER_SECRET_GHOST(), KDF_LABEL(S_AP_TRAFFIC()))

func CLIENT_WRITE_KEY_0_GHOST() = gexpand<enckey;0>(CLIENT_APPLICATION_TRAFFIC_SECRET_0_GHOST(), KDF_LABEL(KEY()))
func CLIENT_WRITE_IV_0_GHOST() = gexpand<nonce |counter|;0>(CLIENT_APPLICATION_TRAFFIC_SECRET_0_GHOST(), KDF_LABEL(IV()))

func SERVER_WRITE_KEY_0_GHOST() = gexpand<enckey;0>(SERVER_APPLICATION_TRAFFIC_SECRET_0_GHOST(), KDF_LABEL(KEY()))
func SERVER_WRITE_IV_0_GHOST() = gexpand<nonce |counter|;0>(SERVER_APPLICATION_TRAFFIC_SECRET_0_GHOST(), KDF_LABEL(IV()))

nametype ClientApplicationWriteKey = st_aead ClientInnerRecord
    aad x. true // TODO: header
    nonce client_application_traffic_counter
    pattern i. xor(i, CLIENT_WRITE_IV_0_GHOST()) // TODO: xor with server_write_iv

nametype ServerApplicationWriteKey = st_aead Name(server_data)
    aad x. true // TODO: header
    nonce server_application_traffic_counter // TODO: xor with server_write_iv

// TODO: not exactly correct (e.g. add expand and change to AEAD)
nametype ClientHandshakeTrafficSecret = nonce
nametype ServerHandshakeTrafficSecret = enckey ServerCertificate

nametype ClientApplicationTrafficSecret = expandkey {info.
    // client_write_key_0
    // TODO: technically this should not be a full kdf call
    // but rather a partial HKDF-Expand call
    info == KDF_LABEL(KEY()) -> strict ClientApplicationWriteKey,

    // client_write_iv_0
    info == KDF_LABEL(IV()) -> public nonce |counter|

    // TODO: client_application_traffic_secret_N with N > 0
}

nametype ServerApplicationTrafficSecret = expandkey {info.
    // server_write_key_0
    // TODO: technically this should not be a full kdf call
    // but rather a partial HKDF-Expand call
    info == KDF_LABEL(KEY()) -> strict ServerApplicationWriteKey,

    // server_write_iv_0
    info == KDF_LABEL(IV()) -> public nonce |counter|

    // TODO: server_application_traffic_secret_N with N > 0
}

// Conflating the names of name/ordinary types here
struct ClientHandshakeTrafficSecret {
    chts_master_secret: Ghost,
    chts_label: Ghost,
    chts_secret:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(Expand<nonce;0;ClientHandshakeTrafficSecret>(chts_master_secret, chts_label))
        else
            Data<adv>
}

struct ServerHandshakeTrafficSecret {
    shts_master_secret: Ghost,
    shts_label: Ghost,
    shts_secret:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(Expand<enckey;0;ServerHandshakeTrafficSecret>(shts_master_secret, shts_label))
        else
            Data<adv>
}

struct ClientApplicationTrafficSecret {
    cats_master_secret: Ghost,
    cats_label: Ghost,
    cats_secret:
        x: if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(Expand<expandkey;0;ClientApplicationTrafficSecret>(cats_master_secret, cats_label))
        else
            Data<adv>
        // To make the AEAD pattern to go through
        { x == CLIENT_APPLICATION_TRAFFIC_SECRET_0_GHOST() }
}

struct ServerApplicationTrafficSecret {
    sats_master_secret: Ghost,
    sats_label: Ghost,
    sats_secret:
        x: if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(Expand<expandkey;0;ServerApplicationTrafficSecret>(sats_master_secret, sats_label))
        else
            Data<adv>
        { x == SERVER_APPLICATION_TRAFFIC_SECRET_0_GHOST() }
}

// RFC 8446 Section 7.1
odh key_schedule : client_dh_sk, server_dh_sk -> expandkey {info.
    info == KDF_LABEL(C_HS_TRAFFIC()) -> strict ClientHandshakeTrafficSecret,
    info == KDF_LABEL(S_HS_TRAFFIC()) -> strict ServerHandshakeTrafficSecret,

    // Master Secret
    info == KDF_LABEL(DERIVED()) -> strict extractkey expandkey {info.
        info == KDF_LABEL(C_AP_TRAFFIC()) -> strict ClientApplicationTrafficSecret,
        info == KDF_LABEL(S_AP_TRAFFIC()) -> strict ServerApplicationTrafficSecret
    }
}

// ClientRandom and ServerRandom in the hello messages are public
corr adv ==> [client_random]
corr adv ==> [server_random]

// If the certificate key is corrupted, we are susceptible to MITM
// TODO: is this correct?
corr [server_cert_key] ==> [server_dh_sk] /\ [client_dh_sk]
