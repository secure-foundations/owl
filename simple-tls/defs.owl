/**
 * Naming conventions:
 * 1. Names, odh, kdf, procedure, counter declarations use snake_case
 * 2. Structs, enums, and name types use CamelCase
 * 3. Functions use capitalized SNAKE_CASE (except for uninterpreted functions)
 * 4. Fields of a struct are named as <StructName>_<field_name>
 * 5. Local variables are snake_case
 */

locality client
locality server

// Some constant labels (Section 7.1)
func TLS13_() = 0x746c73313320
func DERIVED() = 0x64657269766564
func C_HS_TRAFFIC() = 0x632068732074726166666963
func S_HS_TRAFFIC() = 0x732068732074726166666963
func C_AP_TRAFFIC() = 0x632061702074726166666963
func S_AP_TRAFFIC() = 0x732061702074726166666963
func KEY() = 0x6b6579
func IV() = 0x6976

// ContentType's
func CTYPE_ALERT() = 0x15
func CTYPE_HANDSHAKE() = 0x16
func CTYPE_APPLICATION_DATA() = 0x17

// AlertDescription's
func ALERT_DESC_CLOSE_NOTIFY() = 0x00

// TODO: add context (hash of previous messages)
//Ssee Section 7.1
func KDF_LABEL(lbl) = TLS13_() ++ lbl

// We don't support PSK yet
// TODO: should we pad it to a certain length?
func PSK() = 0x00

// Placeholder for unsupported functions in Owl
func leq arity 2
func geq arity 2
func minus arity 2
func as_u16 arity 1
func subrange arity 3

name client_data : nonce @ client
name client_random : nonce @ client
name client_dh_sk : DH @ client

name server_data : nonce @ server
name server_random : nonce @ server
name server_dh_sk : DH @ server

func DH_SHARED_SECRET() = dh_combine(dhpk(get(client_dh_sk)), get(server_dh_sk))

// TODO: X.509 certificate simplified to a signing key
name server_cert_key : sigkey dhpk(server_dh_sk) @ server

// Highly simplified version of TLS ClientHello
// TODO: cipher suite negotiation, extensions, etc.
struct ClientHello {
    ClientHello_random: Name(client_random),
    ClientHello_pk: dhpk(client_dh_sk)
}

// Highly simplified version of TLS ServerHello
struct ServerHello {
    ServerHello_random: Name(server_random),
    ServerHello_pk: dhpk(server_dh_sk)
}

// Merged version of Server Certificate and Certificate Verify
struct ServerCertificate {
    ServerCertificate_cert: vk(server_cert_key),
    ServerCertificate_sig: Data<adv> ||signature||
}

// For sending
counter client_application_traffic_counter @ client
counter server_application_traffic_counter @ server

// For receiving
counter client_application_traffic_counter_recv @ server
counter server_application_traffic_counter_recv @ client

// TODO: is this the correct definition?
struct ClientInnerRecord {
    InnerRecord_content: Name(client_data),
    InnerRecord_type: Data<adv> |1| // TODO: need to be public since we want to branch on it?
    // TODO: padding
}

// TODO: change to AEAD
nametype ClientHandshakeTrafficKey = nonce
nametype ServerHandshakeTrafficKey = enckey ServerCertificate

// Similar to the exec version of key derivation, but in ghost mode
// so that they can be used in types
func EARLY_SECRET_DERIVED_GHOST() = gkdf<nonce;0>(0x00, PSK(), KDF_LABEL(C_HS_TRAFFIC()))
func CLIENT_HANDSHAKE_TRAFFIC_SECRET_GHOST() = gkdf<nonce;0>(EARLY_SECRET_DERIVED_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(C_HS_TRAFFIC()))
func SERVER_HANDSHAKE_TRAFFIC_SECRET_GHOST() = gkdf<enckey;0>(EARLY_SECRET_DERIVED_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(S_HS_TRAFFIC()))
func HANDSHAKE_SECRET_DERIVED_GHOST() = gkdf<kdfkey;0>(EARLY_SECRET_DERIVED_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(DERIVED()))

func CLIENT_APPLICATION_TRAFFIC_SECRET_0_GHOST() = gkdf<kdfkey;0>(HANDSHAKE_SECRET_DERIVED_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(C_AP_TRAFFIC()))
func SERVER_APPLICATION_TRAFFIC_SECRET_0_GHOST() = gkdf<kdfkey;0>(HANDSHAKE_SECRET_DERIVED_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(S_AP_TRAFFIC()))

func CLIENT_WRITE_KEY_0_GHOST() = gkdf<enckey;0>(CLIENT_APPLICATION_TRAFFIC_SECRET_0_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(KEY()))
func CLIENT_WRITE_IV_0_GHOST() = gkdf<nonce |counter|;0>(CLIENT_APPLICATION_TRAFFIC_SECRET_0_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(IV()))

func SERVER_WRITE_KEY_0_GHOST() = gkdf<enckey;0>(SERVER_APPLICATION_TRAFFIC_SECRET_0_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(KEY()))
func SERVER_WRITE_IV_0_GHOST() = gkdf<nonce |counter|;0>(SERVER_APPLICATION_TRAFFIC_SECRET_0_GHOST(), DH_SHARED_SECRET(), KDF_LABEL(IV()))

nametype ClientApplicationTrafficKey = st_aead ClientInnerRecord
    aad x. true // TODO: header
    nonce client_application_traffic_counter
    pattern i. xor(i, CLIENT_WRITE_IV_0_GHOST()) // TODO: xor with server_write_iv

nametype ServerApplicationTrafficKey = st_aead Name(server_data)
    aad x. true // TODO: header
    nonce server_application_traffic_counter // TODO: xor with server_write_iv

odh key_schedule : client_dh_sk, server_dh_sk -> {salt info.
    // client_handshake_traffic_secret
    // TODO: I'm conflating client_handshake_traffic_secret and client_write_key here
    // since the latter is derived from the former via another HKDF-Expand call
    info == KDF_LABEL(C_HS_TRAFFIC()) -> strict ClientHandshakeTrafficKey, // TODO: ClientHandshakeFinished

    // server_handshake_traffic_secret
    info == KDF_LABEL(S_HS_TRAFFIC()) -> strict ServerHandshakeTrafficKey,

    // Master Secret
    info == KDF_LABEL(DERIVED()) -> strict kdf {ikm info.
        // client_application_traffic_secret_0
        info == KDF_LABEL(C_AP_TRAFFIC()) -> strict kdf {ikm info.
            // client_write_key_0
            // TODO: technically this should not be a full kdf call
            // but rather a partial HKDF-Expand call
            info == KDF_LABEL(KEY()) -> strict ClientApplicationTrafficKey,

            // client_write_iv_0
            info == KDF_LABEL(IV()) -> public nonce |counter|
        },

        // server_application_traffic_secret_0
        info == KDF_LABEL(S_AP_TRAFFIC()) -> strict kdf {ikm info.
            // server_write_key_0
            // TODO: technically this should not be a full kdf call
            // but rather a partial HKDF-Expand call
            info == KDF_LABEL(KEY()) -> strict ServerApplicationTrafficKey,

            // server_write_iv_0
            info == KDF_LABEL(IV()) -> public nonce |counter|
        }
    }
}

// ClientRandom and ServerRandom in the hello messages are public
corr adv ==> [client_random]
corr adv ==> [server_random]

// If the certificate key is corrupted, we are susceptible to MITM
// TODO: is this correct?
corr [server_cert_key] ==> [server_dh_sk] /\ [client_dh_sk]
