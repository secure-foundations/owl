/**
 * Naming conventions:
 * 1. Names, odh, kdf, procedure, counter declarations use snake_case
 * 2. Structs, enums, and name types use CamelCase
 * 3. Functions use capitalized SNAKE_CASE (except for uninterpreted functions)
 * 4. Fields of a struct are named as <struct abbreviation>_<field_name>
 * 5. Local variables are snake_case
 */

// Placeholder for unsupported functions in Owl
func leq arity 2
func geq arity 2
func minus arity 2
func as_u16 arity 1
func subrange arity 3

locality client
locality server

// Some constant labels (Section 7.1)
func DERIVED() = "derived"
func C_E_TRAFFIC() = "c e traffic"
func C_HS_TRAFFIC() = "c hs traffic"
func S_HS_TRAFFIC() = "s hs traffic"
func C_AP_TRAFFIC() = "c ap traffic"
func S_AP_TRAFFIC() = "s ap traffic"
func KEY() = "key"
func IV() = "iv"

// ContentType's
func CTYPE_ALERT() = 0x15
func CTYPE_HANDSHAKE() = 0x16
func CTYPE_APPLICATION_DATA() = 0x17

// AlertDescription's
func ALERT_DESC_CLOSE_NOTIFY() = 0x00

// struct HKDFContext {
//     HKDFContext_len: Data<adv> |2|,
//     HKDFContext_label_pref: Const(0x746c73313320), // "tls13 "
//     HKDFContext_label: Data<adv>
//     // HKDFContext_context: Data<adv> ||crh||
// }

// TODO: make sure |crh| has the correct length (u16)
// TODO: add context (hash of previous messages)
// see Section 7.1
func KDF_LABEL(lbl) = as_u16(|crh|) ++ "tls13 " ++ lbl

// struct KDFLabel {
//     kl_len: Data<adv> |2|,
//     kl_label_pref: Const("tls13 "),
//     kl_label: Data<adv>
// }

// We don't support PSK yet
// TODO: should we pad it to a certain length?
func PSK() = 0x00
func HASH_LEN_0() = 0x00 // TODO: pad it to |crh|

name client_data : nonce @ client
name client_random : nonce @ client
name client_dh_sk : DH @ client

name server_data : nonce @ server
name server_random : nonce @ server
name server_dh_sk : DH @ server

func DH_SHARED_SECRET() = dh_combine(dhpk(get(client_dh_sk)), get(server_dh_sk))

// TODO: X.509 certificate simplified to a signing key
name server_cert_key : sigkey dhpk(server_dh_sk) @ server

// Highly simplified version of TLS ClientHello
// TODO: cipher suite negotiation, extensions, etc.
struct ClientHello {
    ch_random: Name(client_random),
    ch_pk: dhpk(client_dh_sk)
}

// Highly simplified version of TLS ServerHello
struct ServerHello {
    sh_random: Name(server_random),
    sh_pk: dhpk(server_dh_sk)
}

// Merged version of Server Certificate and Certificate Verify
struct ServerCertificate {
    sc_cert: vk(server_cert_key),
    sc_sig: Data<adv> ||signature||
}

// For sending
counter client_application_traffic_counter @ client
counter server_application_traffic_counter @ server

// For receiving
counter client_application_traffic_counter_recv @ server
counter server_application_traffic_counter_recv @ client

def client_send @ client
def server_send @ server

type ClientData = x : Data<adv /\ [client_data], |adv|> { happened(client_send(x)) }
type ServerData = x : Data<adv /\ [server_data], |adv|> { happened(server_send(x)) }

struct ClientInnerRecord {
    // TODO: in the actual definition (TLSInnerPlaintext in RFC 8446)
    // this content type actually comes after content
    // but we assume that this permutation is handled in Vest
    ir_type: Data<adv> |1|,

    ir_content:
        if ir_type == CTYPE_APPLICATION_DATA() then
            ClientData
        else
            Data<adv>

    // TODO: padding handled in Vest
}

struct ServerInnerRecord {
    si_type: Data<adv> |1|,
    si_content:
        if si_type == CTYPE_APPLICATION_DATA() then
            ServerData
        else
            Data<adv>
}

// TODO: not exactly correct (e.g. add expand and change to AEAD)
nametype ClientHandshakeTrafficSecret = nonce
nametype ServerHandshakeTrafficSecret = enckey ServerCertificate

// TODO: recursively define client_application_traffic_secret_N with N > 0
nametype ClientApplicationTrafficSecret = expandkey {info self.
    // client_write_key
    // TODO: technically this should not be a full kdf call
    // but rather a partial HKDF-Expand call
    info == KDF_LABEL(KEY()) -> strict st_aead ClientInnerRecord
        aad x. true // TODO: header
        nonce client_application_traffic_counter
        pattern i. xor(i, gexpand<nonce |counter|;0>(self, KDF_LABEL(IV()))),

    // client_write_iv
    info == KDF_LABEL(IV()) -> public nonce |counter|
}

// TODO: recursively define server_application_traffic_secret_N with N > 0
nametype ServerApplicationTrafficSecret = expandkey {info self.
    // server_write_key_0
    // TODO: technically this should not be a full kdf call
    // but rather a partial HKDF-Expand call
    info == KDF_LABEL(KEY()) -> strict st_aead ServerInnerRecord
        aad x. true // TODO: header
        nonce client_application_traffic_counter
        pattern i. xor(i, gexpand<nonce |counter|;0>(self, KDF_LABEL(IV()))),

    // server_write_iv_0
    info == KDF_LABEL(IV()) -> public nonce |counter|
}

// Conflating the names of name/ordinary types here
struct ClientHandshakeTrafficSecret {
    chts_master_secret: Ghost,
    chts_label: Ghost,
    chts_secret:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(Expand<nonce;0;ClientHandshakeTrafficSecret>(chts_master_secret, chts_label))
        else
            Data<adv>
}

struct ServerHandshakeTrafficSecret {
    shts_master_secret: Ghost,
    shts_label: Ghost,
    shts_secret:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(Expand<enckey;0;ServerHandshakeTrafficSecret>(shts_master_secret, shts_label))
        else
            Data<adv>
}

struct ClientApplicationTrafficSecret {
    cats_master_secret: Ghost,
    cats_label: Ghost,
    cats_secret:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(Expand<expandkey;0;ClientApplicationTrafficSecret>(cats_master_secret, cats_label))
        else
            Data<adv>
}

struct ServerApplicationTrafficSecret {
    sats_master_secret: Ghost,
    sats_label: Ghost,
    sats_secret:
        if sec(client_dh_sk) /\ sec(server_dh_sk) then
            SecName(Expand<expandkey;0;ServerApplicationTrafficSecret>(sats_master_secret, sats_label))
        else
            Data<adv>
}

// RFC 8446 Section 7.1
odh key_schedule : client_dh_sk, server_dh_sk -> expandkey {info.
    info == KDF_LABEL(C_HS_TRAFFIC()) -> strict ClientHandshakeTrafficSecret,
    info == KDF_LABEL(S_HS_TRAFFIC()) -> strict ServerHandshakeTrafficSecret,

    // Master Secret
    info == KDF_LABEL(DERIVED()) -> strict extractkey expandkey {info.
        info == KDF_LABEL(C_AP_TRAFFIC()) -> strict ClientApplicationTrafficSecret,
        info == KDF_LABEL(S_AP_TRAFFIC()) -> strict ServerApplicationTrafficSecret
    }
}

// ClientRandom and ServerRandom in the hello messages are public
corr adv ==> [client_random]
corr adv ==> [server_random]

// If the certificate key is corrupted, we are susceptible to MITM
// TODO: is this correct?
corr [server_cert_key] ==> [server_dh_sk] /\ [client_dh_sk]
