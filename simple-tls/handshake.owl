// A highly simplified TLS handshake process

include "defs.owl"

// Resulting secrets from the handshake
struct HandshakeResult {
    hr_client_handshake_secret: ClientHandshakeTrafficSecret,
    hr_server_handshake_secret: ServerHandshakeTrafficSecret,
    hr_client_app_secret: ClientApplicationTrafficSecret,
    hr_server_app_secret: ServerApplicationTrafficSecret
}

// client_hello is given has argument since we don't
// know if client_dh_sk <= adv
def server_handshake(msg: ClientHello) @ server : Option(HandshakeResult)
    =
    parse msg as ClientHello(_, client_dh_pk) in
        let _ = output ServerHello(get(server_random), dhpk(get(server_dh_sk))) to endpoint(client) in
        let sk = dh_combine(client_dh_pk, get(server_dh_sk)) in

        corr_case client_dh_sk in
        corr_case server_dh_sk in

        // Key schedule in Section 7.1
        let ctx = crh("") in // TODO: take ctx to be the transcript hash

        let early_secret = extract(HASH_LEN_0(), PSK()) in
        let early_secret_derived = expand<0;extractkey;0>(early_secret, LABEL(|extractkey|, "derive", ctx)) in

        let handshake_secret = extract<key_schedule>(early_secret_derived, sk) in
        let client_handshake_traffic_secret = expand<0;nonce;0>(handshake_secret, LABEL(|enckey|, "c hs traffic", ctx)) in
        let server_handshake_traffic_secret = expand<1;enckey;0>(handshake_secret, LABEL(|enckey|, "s hs traffic", ctx)) in
        let handshake_secret_derived = expand<2;extractkey;0>(handshake_secret, LABEL(|extractkey|, "derived", ctx)) in

        let master_secret = extract(handshake_secret_derived, HASH_LEN_0()) in
        let client_application_traffic_secret_0 = expand<0;expandkey;0>(master_secret, LABEL(|expandkey|, "c ap traffic", ctx)) in
        let server_application_traffic_secret_0 = expand<1;expandkey;0>(master_secret, LABEL(|expandkey|, "s ap traffic", ctx)) in

        // Send certificate and certificate verify
        // TODO: this needs to sign the server_hello message instead of just the DH key
        let sig = sign(get(server_cert_key), dhpk(get(server_dh_sk))) in
        let msg = ServerCertificate(get_vk(server_cert_key), sig) in

        // TODO: change to AEAD
        let msg = aenc(server_handshake_traffic_secret, msg) in
        let _ = output msg to endpoint(client) in

        // TODO: send Finished

        Some(HandshakeResult(
            ClientHandshakeTrafficSecret(handshake_secret, LABEL(|enckey|, "c hs traffic", ctx), client_handshake_traffic_secret),
            ServerHandshakeTrafficSecret(handshake_secret, LABEL(|enckey|, "s hs traffic", ctx), server_handshake_traffic_secret),
            ClientApplicationTrafficSecret(master_secret, LABEL(|expandkey|, "c ap traffic", ctx), client_application_traffic_secret_0),
            ServerApplicationTrafficSecret(master_secret, LABEL(|expandkey|, "s ap traffic", ctx), server_application_traffic_secret_0)
        ))
    otherwise
        None()

def client_handshake() @ client : Option(HandshakeResult)
    =
    let _ = output ClientHello(get(client_random), dhpk(get(client_dh_sk))) to endpoint(server) in
    input msg in
    parse msg as ServerHello(_, server_dh_pk) in
        let sk = dh_combine(server_dh_pk, get(client_dh_sk)) in

        // Same process as the server
        corr_case client_dh_sk in
        corr_case server_dh_sk in

        // TODO: prfodh
        assume(server_dh_pk == dhpk(get(server_dh_sk)));

        // Key schedule in Section 7.1
        let ctx = "" in // TODO: take ctx to be the transcript hash
        let early_secret = extract(HASH_LEN_0(), PSK()) in
        let early_secret_derived = expand<0;extractkey;0>(early_secret, LABEL(|extractkey|, "derive", ctx)) in

        let handshake_secret = extract<key_schedule>(early_secret_derived, sk) in
        let client_handshake_traffic_secret = expand<0;nonce;0>(handshake_secret, LABEL(|enckey|, "c hs traffic", ctx)) in
        let server_handshake_traffic_secret = expand<1;enckey;0>(handshake_secret, LABEL(|enckey|, "s hs traffic", ctx)) in
        let handshake_secret_derived = expand<2;extractkey;0>(handshake_secret, LABEL(|extractkey|, "derived", ctx)) in

        let master_secret = extract(handshake_secret_derived, HASH_LEN_0()) in
        let client_application_traffic_secret_0 = expand<0;expandkey;0>(master_secret, LABEL(|expandkey|, "c ap traffic", ctx)) in
        let server_application_traffic_secret_0 = expand<1;expandkey;0>(master_secret, LABEL(|expandkey|, "s ap traffic", ctx)) in

        // TODO: send Finished

        input msg in
        case adec(server_handshake_traffic_secret, msg) {
            | None => None()
            | Some msg =>
                parse msg as ServerCertificate(_, sig) in
                    corr_case server_cert_key in
                    case vrfy(get_vk(server_cert_key), server_dh_pk, sig) {
                        | Some server_dh_pk_verified =>
                            Some(HandshakeResult(
                                ClientHandshakeTrafficSecret(handshake_secret, LABEL(|enckey|, "c hs traffic", ctx), client_handshake_traffic_secret),
                                ServerHandshakeTrafficSecret(handshake_secret, LABEL(|enckey|, "s hs traffic", ctx), server_handshake_traffic_secret),
                                ClientApplicationTrafficSecret(master_secret, LABEL(|expandkey|, "c ap traffic", ctx), client_application_traffic_secret_0),
                                ServerApplicationTrafficSecret(master_secret, LABEL(|expandkey|, "s ap traffic", ctx), server_application_traffic_secret_0)
                            ))
                        | None => None()
                    }
                otherwise None()
        }
    otherwise None()
