include "ke.owli"

name S : DH @ Server
name C : DH @ Client
name skS : sigkey (dhpk(S)) @ Server
name skC : sigkey (dhpk(C)) @ Client

odh L : C, S -> 
    {salt info.
        True -> strict enckey Name(k)
    }

struct server_msg {
    _s1: dhpk(S),
    _s2: Data<adv> ||signature||
}

struct client_msg {
    _c1: dhpk(C),
    _c2: Data<adv> ||signature||
}

// todo: make these smaller
corr [skC] ==> [k]
corr [skS] ==> [k]
corr [C] ==> [k]
corr [S] ==> [k]
corr [skS] ==> [S]
corr [skS] ==> [C]
corr [k] ==> [skS]

def ke_Server () @ Server
    //requires corr(skC) ==> corr(k) // TODO: this is artificial
: Unit = 
    let vkC: vk(skC) = get_vk(skC) in
    let signed_s = sign(get(skS), dhpk(get(S))) in
    let a = server_msg(dhpk(get(S)), signed_s) in
    let _ = output a to endpoint(Client) in
    input i, _ in 
    corr_case skC in
    parse i as client_msg(c1, c2) in
    case vrfy(vkC, c1, c2) {
     | Some client_pk => 
       corr_case S in 
       corr_case C in 
       let ss  = dh_combine(client_pk, get(S)) in
       pcase (ss == dh_combine(dhpk(get(C)), get(S))) in 
       let dhk = kdf<;odh L[0];enckey;0>(0x, ss, 0x) in 
       let c =  aenc(dhk, get(k)) in
       corr_case k in
       false_elim in
       assert (([skC] <= adv) ==> ([k] <= adv)); 
       let _ = output c to endpoint(Client) in 
       ()
     | None => ()
    }
    otherwise ()


def ke_Client () @ Client
    // requires corr(skS) ==> corr(k)
:  Option (if sec(k) then Name(k) else Data<adv>) = 
    let vkS: vk(skS) = get_vk(skS) in
    let signed_c = sign(get(skC), dhpk(get(C))) in
    let b = client_msg(dhpk(get(C)), signed_c) in
    let _ = output b to endpoint(Server) in
    input i, _ in 
    corr_case skS in
    parse i as server_msg(s1, s2) in
    case vrfy(vkS, s1, s2) {
     | Some server_pk => 
       let ss  = dh_combine(server_pk, get(C)) in
       pcase (ss == dh_combine(dhpk(get(C)), get(S))) in 
       let dhk = kdf<;odh L[0];enckey;0>(0x,ss, 0x) in
       input ii, _ in 
       corr_case k in 
       false_elim in
       case adec(dhk, ii) {
       | None => None<ty: if sec(k) then Name(k) else Data<adv> >()
       | Some dd => 
         let ddd : if sec(k) then Name(k) else Data<adv> = dd in
         // Some(ddd)
         None<ty: if sec(k) then Name(k) else Data<adv> >()
       }
     | None => None<ty: if sec(k) then Name(k) else Data<adv> >()
    }
    otherwise None<ty: if sec(k) then Name(k) else Data<adv> >()
