locality alice

name n<i> : nonce
name k1<i> : enckey Name(n<succ(i)>)

// Parser should fail
// name k2<succ(i)> : nonce

// TODO: do we want to allow this?
name k2<i>: enckey Name(k2<succ(i)>)

// Should fail
// name k3<i> : enckey Name(k3<i>)

nametype rec3<i> = kdf {ikm info.
    info == 0x01 -> nonce,
    info == 0x02 -> strict rec3<succ(i)>
}
name k3<i> : rec3<i>

name a : DH @ alice
name b : DH @ alice
name data : nonce @ alice

nametype rec4<i> = kdf {ikm info.
    info == 0x01 -> enckey Name(data),
    // info == 0x02 -> strict kdf {ikm info.
    //     info == 0x01 -> strict rec4<succ(i)>
    // }
    info == 0x02 -> strict rec4<succ(i)>
}

odh schedule : a, b -> {salt info.
    info == 0x01 -> enckey Name(data),
    info == 0x02 -> strict rec4<0>
} 

def pasta<i>(k: Name(k3<i>)) @ alice : Unit
    =
    let k = kdf<1;;kdfkey;0>(k, 0x00, 0x02) in
    let k = kdf<1;;kdfkey;0>(k, 0x00, 0x02) in
    let k = kdf<1;;kdfkey;0>(k, 0x00, 0x02) in
    let k = kdf<1;;kdfkey;0>(k, 0x00, 0x02) in
    let _ = kdf<0;;nonce;0>(k, 0x00, 0x01) in
    ()

def pasta2<i>(k_pre: Ghost, k: SecName(KDF<kdfkey; 0; rec3<i>>(k_pre, 0x00, 0x02))) @ alice
    : SecName(KDF<kdfkey; 0; rec3<succ(i)>>(k, 0x00, 0x02))
    = kdf<1;;kdfkey;0>(k, 0x00, 0x02)

def pasta3<i>(k_pre: Ghost, k: SecName(KDF<kdfkey; 0; rec3<i>>(k_pre, 0x00, 0x02))) @ alice
    : SecName(KDF<kdfkey; 0; rec3<succ(succ(i))>>(gkdf<kdfkey;0>(k, 0x00, 0x02), 0x00, 0x02))
    =
    let k = kdf<1;;kdfkey;0>(k, 0x00, 0x02) in
    let k = kdf<1;;kdfkey;0>(k, 0x00, 0x02) in
    k

struct Ticket<i> {
    pre_salt: Ghost,
    pre_ikm: Ghost,
    k: SecName(KDF<kdfkey; 0; rec4<i>>(pre_salt, pre_ikm, 0x02))
}

enum Maybe<i> {
    | Just Ticket<session i>
    | Nothing
}

def pasta4<i>(ticket: Maybe<session i>) @ alice
    : if Just?(ticket) then Ticket<session succ(i)>
      else (if sec(a) /\ sec(b) then Ticket<session 0> else Data<adv>)
    =
    case ticket {
        | Just t =>
            parse t as Ticket<session i>(_, _, k) in
            let new_k = kdf<1;;kdfkey;0>(k, 0x00, 0x02) in
            Ticket<session succ(i)>(k, 0x00, new_k)
        | Nothing =>
        
            let a = get(a) in
            let b = get(b) in
            let secret = dh_combine(dhpk(a), b) in
            corr_case a in
            corr_case b in
            let k = kdf<;odh schedule[1];kdfkey;0>(0x00, secret, 0x02) in
            Ticket<session 0>(0x00, secret, k)
    }
