/*
 Owl implementations of the Kerberos protocol in both standard (all keys
 pre-shared) mode and PK_INIT mode, where initial set-up between the
 client and authentication server uses a public key infrastructure.

 Key hierarchy for STANDARD mode:

  kC    kT
   \    /
     AK    kS
      \    /
        SK

 Key hierarchy for PK_INIT mode:

            sigCA
             |
     pkeC   sigA
        \   /
  kT      K
    \    / 
      AK    kS
       \    /
         SK
 
  where:
  - kX   = pre-shared symmetric key
  - pkeX = secret key for PKE
  - sigX = signing key
  - XK   = symmetric key generated by X
 
  - C  = client
  - A  = authentication server
  - T  = ticket server
  - S  = service
  - CA = certificate authority
*/


// *********************************
// localities
// *********************************

locality ticketserver // TGS
locality service // S
locality client // C
locality authserver // KAS

// PK_INIT-only localities
locality certauth

name uname : nonce @ ticketserver, service, client, authserver, certauth
flow [uname] <= adv
flow [uname] <= static

// *********************************
// keys for Kerberos stages 2 and 3
// *********************************

// SK = service key
name SK : enckey Data<static> @ ticketserver

// messages to/from the ticket server
// encrypted using AK
enum AKEnum {
    | ClientRequest
    | TicketResponse Name(SK)
}

// AK = authserver key
name AK : enckey AKEnum @ authserver

// pre-shared symmetric keys
name kT : enckey Name(AK) @ authserver, ticketserver
name kS : enckey Name(SK) @ ticketserver, service

// *********************************
// pre-shared key for STANDARD mode
// *********************************

name kC : enckey Name(AK) @ authserver, client


// *********************************
// keys for PK_INIT mode
// *********************************

// shared key obtained by client through PKE
name K : enckey Name(AK) @ authserver

// client's signing key; client signs her username
// (TODO: client signs a timestamp and nonce)
name sigkeyC : sigkey Name(uname) @ client

// authserver signing key; authserver signs K
// (TODO: authserver signs K and a checksum of client's msg)
name sigkeyA : sigkey Name(K) @ authserver

// sigkeyCA is a certificate authority key that can sign
// verification keys for the client and authserver
enum CertAuthMsgs {
     | ClientCert vk(sigkeyC)
     | AuthCert vk(sigkeyA)
}

name sigkeyCA : sigkey CertAuthMsgs @ certauth


// client decrypts msg from authserver where
// msg = concat(AuthCert, vk(sigkeyA), k, sign(sigkeyA, k))
// seckeyC gets label adv + highest label from msg

// name seckeyC : pkekey Data<adv /\ [K], |static|> @ client


// *********************************
// message formats
// *********************************

struct authserver_msg {
    _authserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _authserver_msg_2 : Data<adv> |cipherlen(|enckey|)|
}

struct client_to_ticketserver_msg {
    _client_to_ticketserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _client_to_ticketserver_msg_2 : Data<adv> |cipherlen(|tag|)|
}

struct ticketserver_msg {
    _ticketserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _ticketserver_msg_2 : Data<adv> |cipherlen(plus(|tag|, |enckey|))|
}

struct client_to_service_msg {
    _client_to_service_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _client_to_service_msg_2 : Data<adv> |cipherlen(|nonce|)|
}

struct pkinit_client_to_authserver_msg {
    _pkinit_client_to_authserver_msg_1 : Data<adv> ||signature||,
    _pkinit_client_to_authserver_msg_2 : Data<adv> ||sigkey||,
    _pkinit_client_to_authserver_msg_3 : Data<adv> ||signature||,
    _pkinit_client_to_authserver_msg_4 : Data<adv> ||nonce||
}

struct ClientPKResponse { 
    _AuthCert : Data<adv> ||signature||,
    _vkA : vk(sigkeyA), 
    _k : Name(K),
    _sigofK : Data<[K] /\ static> ||signature||
}

name seckeyCnew : pkekey ClientPKResponse @ client

// *********************************
// uninterpreted functions
// *********************************

// parsing is all selecting slices from a bitstring
// magic_parse(-) used in place of proper slicing for now
// func magic_parse
//      arity 1

// func magic_deparse
//      arity 1

// // joins two bitstrings
// func concat
//      arity 2

// *********************************
// implementations
// *********************************

// TODO: need support for multiple input keys in at the type-level so we can pass in kC or K
//       depending on the version of the protocol we're running.

// for now: temporary copy of stages 2 and 3 pasted below with K instead of kC (only difference)
def client_kerberos (ak: if sec(kC) then Name(AK) else Data<adv>, tgt : Data<adv> |cipherlen(|enckey|)|, username : Data<static> ||nonce||) @ client
    : Unit = 
    corr_case AK in
    corr_case kC in
    let m = samp enc(ak, ClientRequest()) in
    let p = client_to_ticketserver_msg(tgt, m) in
    let _ = output p to endpoint(ticketserver) in

    input i' in 
    let service_ticket = _ticketserver_msg_1(i') in
    (case dec(ak, _ticketserver_msg_2(i')) 
        | None => ()
        | Some res =>
            (case res 
                | ClientRequest => () 
                | TicketResponse sk => 
                let m' = samp enc(sk, username) in
                let p' = client_to_service_msg(service_ticket, m') in
                let _ = output p' to endpoint(service) in 
                // wait for service's response
                input _ in () ))

def client_kerberos_tmpcopy (ak: if sec(K) then Name(AK) else Data<adv>, tgt : Data<adv>, username : Data<static>) @ client
    : Unit = 
    corr_case AK in
    corr_case K in
    let m = samp enc(ak, ClientRequest()) in
    let p = client_to_ticketserver_msg(tgt, m) in
    let _ = output p to endpoint(ticketserver) in

    input i' in 
    let service_ticket = _ticketserver_msg_1(i') in
    (case dec(ak, _ticketserver_msg_2(i')) 
        | None => ()
        | Some res =>
            (case res 
                | ClientRequest => () 
                | TicketResponse sk => 
                let m' = samp enc(sk, username) in
                let p' = client_to_service_msg(service_ticket, m') in
                let _ = output p' to endpoint(service) in 
                // wait for service's response
                input _ in () ))


def client_pkinit (certC : Data<adv> ||signature||, vkCA : vk(sigkeyCA)) @ client
    requires ([sigkeyA] <= [sigkeyCA]) /\ ([K] <= [sigkeyCA]) /\ ([K] <= [sigkeyA]) /\ (! ([sigkeyA] <= [K]))
    : Unit =

    // make username
    let username = get(uname) in

    // sign username (TODO: sign a timestamp + nonce instead of username)
    let signed_name = sign(get(sigkeyC), username) in

    // output = {{verkeyC}}_CA, verkeyC, {{username}}_sigkeyC, username
    let p = pkinit_client_to_authserver_msg(certC, get_vk(sigkeyC), signed_name, username) in
    let _ = output p to endpoint(authserver) in

    // i = tgt, (AK)_K, msg = {{certA, verkeyA, k, [k]_sigkeyA}}_pubkeyC 
    input tgt in
    input enc_ak in
    input msg in

    // use pke key seckeyC to decrypt msg
    corr_case seckeyCnew in
    let p' = pkdec(get(seckeyCnew), msg) in
    corr_case K in
    let p = p' in 
    // union_case p = p' in
    // p = {certA, verkeyA, [k]_sigkeyA, k}

    let certA = _AuthCert(p) in 
     // certA = signature of verkeyA signed by sigkeyCA
     corr_case sigkeyCA in
     (
     case vrfy(vkCA, certA, _vkA(p)) // get verkeyA = vk(sigkeyA)
        | Some res =>
            (case res 
              | ClientCert _ => ()
              | AuthCert vkA => 
                // now use verkeyA to verify signed_k
                (corr_case sigkeyA in
                case vrfy(vkA, _k(p), _sigofK(p)) // get K, sign(sigkeyA, k)
                    | Some k =>
                        // finally, decrypt AK using k
                        corr_case K in
                        (
                        case dec(k, enc_ak) 
                            | Some ak =>
                                call client_kerberos_tmpcopy(ak, tgt, username)
                            | None => ()
                        )
                    | None => ()
                )
            )
        | None => ()
        ) 
    

def client_main () @ client
    : Unit =
    
    let username = get(uname) in
    let _ = output username to endpoint(authserver) in

    // i = tgt, enc(kC, AK)
    input i in 

    let tgt = _authserver_msg_1(i) in
    let b = eq(length(tgt), cipherlen(|enckey|)) in
    if b then 
        corr_case kC in
        case dec(get(kC), _authserver_msg_2(i)) 
            | None => ()
            | Some ak =>
                call client_kerberos(ak, tgt, username)
    else ()


def authserver_main () @ authserver
    : Unit =

    // i = client's username
    input i, _ in 
    if eq(i, get(uname)) then

        // make & send TGT = (AK)_kT, m = (AK)_kC
        let tgt = samp enc(get(kT), get(AK)) in

        let m = samp enc(get(kC), get(AK)) in
        let p = authserver_msg(tgt, m) in

        let _ = output p to endpoint(client) in ()
    else ()


def ticketserver_main () @ ticketserver
    : Unit =

    // i = (AK)_kT, (ClientRequest)_AK 
    input i in 
    
    corr_case kT in
    case dec(get(kT), _client_to_ticketserver_msg_1(i)) 
         | None => ()
         | Some ak =>
         
             corr_case AK in
             (case dec(ak, _client_to_ticketserver_msg_2(i)) 
                 | Some ClientRequest =>
                     let st = samp enc(get(kS), get(SK)) in
                     let m = samp enc(ak, TicketResponse(get(SK))) in
                     let p = ticketserver_msg(st, m) in
                     let _ = output p to endpoint(client) in ()
                 | None => ())


def service_main () @ service
    : Unit =

    // i = (SK)_kS, ("client")_SK
    input i in
    
    corr_case kS in
    case dec(get(kS), _client_to_service_msg_1(i)) 
         | None => ()
         | Some sk =>
             corr_case SK in
             (case dec(sk, _client_to_service_msg_2(i)) 
                 | None => ()
                 | Some u =>
                     if eq(u, get(uname)) then
                         let _ = output "" to endpoint(client) in ()
                     else ())

def authserver_pkinit (certA : Data<adv> ||signature||, vkCA : vk(sigkeyCA), pkC : encpk(seckeyCnew)) @ authserver
    requires    ([K] <= [sigkeyC]) /\
                ([K] <= [sigkeyCA])
    : Unit =

    // i = {{verkeyC}}_CA, verkeyC, {{username}}_sigkeyC, username
    input i in 
    let un = _pkinit_client_to_authserver_msg_4(i) in
    let signed_un = _pkinit_client_to_authserver_msg_3(i) in
    corr_case sigkeyCA in
    corr_case sigkeyC in
    corr_case K in 

    // check that we got a good certificate
    case _pkinit_client_to_authserver_msg_1(i) // get client vertificate
         | ClientCert certC =>
         
             // check that certC is valid for vkC
             (
             case vrfy(vkCA, certC, _pkinit_client_to_authserver_msg_2(i)) 
                 | None => ()
                 | Some vkC =>
                 
                     // use verkeyC to verify the username
                     (
                     case vrfy(vkC, signed_un, un) 
                         | None => ()
                         | Some username =>
                         
                             // signed username is equal to the client we expected
                             // TODO: check that a signed timestamp is still fresh
                             if eq(username, get(uname)) then

                                // sign/encrypt/send outputs to client
                                let tgt = samp enc(get(kT), get(AK)) in
                                output tgt to endpoint(client);
                                
                                let enc_ak = samp enc(get(K), get(AK)) in
                                output enc_ak to endpoint(client);
                                
                                // bundle msg and encrypt with pubkeyC
                                let sA = get(sigkeyA) in
                                let k''= get(K) in
                                // let signed_k : Data<adv> ||signature||= sign(sA, k'') in
                                let signed_k = sign(sA, k'') in
                                let b = eq(length(signed_k), |signature|) in
                                if b then
                                    let field1 : Data<adv>||signature|| = certA in 
                                    let field2 : vk(sigkeyA) = get_vk(sigkeyA) in 
                                    let field3 : Name(K) = get(K) in 
                                    // let field4 : Data<adv>||signature|| = signed_k in 
                                    let field4 = signed_k in 
                                    let str : ClientPKResponse = ClientPKResponse(field1, field2, field3, field4) in 
                                    let msg = samp pkenc(pkC, str) in
                                    output msg to endpoint(client); ()
                                else ()
                             else ()
                    )
            )
          | AuthCert x => ()


// not really needed, just to satisfy extraction
def certauth_main () @ certauth : Unit = ()
