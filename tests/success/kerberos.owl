/*
 Owl implementations of the Kerberos protocol in both standard (all keys
 pre-shared) mode and PK_INIT mode, where initial set-up between the
 client and authentication server uses a public key infrastructure.

 Key hierarchy for STANDARD mode:

  kC    kT
   \    /
     AK    kS
      \    /
        SK

 Key hierarchy for PK_INIT mode:

            sigCA
             |
     pkeC   sigA
        \   /
  kT      K
    \    / 
      AK    kS
       \    /
         SK
 
  where:
  - kX   = pre-shared symmetric key
  - pkeX = secret key for PKE
  - sigX = signing key
  - XK   = symmetric key generated by X
 
  - C  = client
  - A  = authentication server
  - T  = ticket server
  - S  = service
  - CA = certificate authority
*/


// *********************************
// localities
// *********************************

locality ticketserver // TGS
locality service // S
locality client // C
locality authserver // KAS

// PK_INIT-only localities
locality certauth

name uname : nonce @ ticketserver, service, client, authserver, certauth
corr adv ==> [uname]

// *********************************
// keys for Kerberos stages 2 and 3
// *********************************

// SK = service key
name SK : enckey Data<adv> @ ticketserver

// messages to/from the ticket server
// encrypted using AK
enum AKEnum {
    | ClientRequest
    | TicketResponse Name(SK)
}

// AK = authserver key
name AK : enckey AKEnum @ authserver

// pre-shared symmetric keys
name kT : enckey Name(AK) @ authserver, ticketserver
name kS : enckey Name(SK) @ ticketserver, service

// *********************************
// pre-shared key for STANDARD mode
// *********************************

name kC : enckey Name(AK) @ authserver, client


// *********************************
// keys for PK_INIT mode
// *********************************

// shared key obtained by client through PKE
name K : enckey Name(AK) @ authserver

// client's signing key; client signs her username
// (TODO: client signs a timestamp and nonce)
name sigkeyC : sigkey Name(uname) @ client

// authserver signing key; authserver signs K
// (TODO: authserver signs K and a checksum of client's msg)
name sigkeyA : sigkey Name(K) @ authserver

// sigkeyCA is a certificate authority key that can sign
// verification keys for the client and authserver
enum CertAuthMsgs {
     | ClientCert vk(sigkeyC)
     | AuthCert vk(sigkeyA)
}

name sigkeyCA : sigkey CertAuthMsgs @ certauth


// client decrypts msg from authserver where
// msg = concat(AuthCert, vk(sigkeyA), k, sign(sigkeyA, k))
// seckeyC gets label adv + highest label from msg

// name seckeyC : pkekey Data<adv /\ [K], |adv|> @ client


// *********************************
// message formats
// *********************************

struct authserver_msg {
    _authserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _authserver_msg_2 : Data<adv> |cipherlen(|enckey|)|
}

struct client_to_ticketserver_msg {
    _client_to_ticketserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _client_to_ticketserver_msg_2 : Data<adv> |cipherlen(|tag|)|
}

struct ticketserver_msg {
    _ticketserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _ticketserver_msg_2 : Data<adv> |cipherlen(plus(|tag|, |enckey|))|
}

struct client_to_service_msg {
    _client_to_service_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _client_to_service_msg_2 : Data<adv> |cipherlen(|nonce|)|
}

struct pkinit_client_to_authserver_msg {
    _pkinit_client_to_authserver_msg_1 : Data<adv> ||signature||,
    _pkinit_client_to_authserver_msg_2 : Data<adv> ||sigkey||,
    _pkinit_client_to_authserver_msg_3 : Data<adv> ||signature||,
    _pkinit_client_to_authserver_msg_4 : Data<adv> ||nonce||
}

struct ClientPKResponse { 
    _AuthCert : Data<adv> ||signature||,
    _vkA : vk(sigkeyA), 
    _k : Name(K),
    _sigofK : Data<[K]> ||signature||
}

name seckeyCnew : pkekey ClientPKResponse @ client

// *********************************
// uninterpreted functions
// *********************************

// parsing is all selecting slices from a bitstring
// magic_parse(-) used in place of proper slicing for now
// func magic_parse
//      arity 1

// func magic_deparse
//      arity 1

// // joins two bitstrings
// func concat
//      arity 2

// *********************************
// implementations
// *********************************

// TODO: need support for multiple input keys in at the type-level so we can pass in kC or K
//       depending on the version of the protocol we're running.

// set_option ":rlimit" "120000"

// for now: temporary copy of stages 2 and 3 pasted below with K instead of kC (only difference)
def client_kerberos (ak: if sec(kC) then Name(AK) else Data<adv>, tgt :
Data<adv> |cipherlen(|enckey|)|, username : Data<adv> ||nonce||) @ client
    : Unit = 
    corr_case AK in
    corr_case kC in
    let m = aenc(ak, ClientRequest()) in
    let p = client_to_ticketserver_msg(tgt, m) in
    let _ = output p to endpoint(ticketserver) in

    input i' in 
    parse i' as ticketserver_msg(service_ticket, c) in {  
        case adec(ak, c) {
            | None => ()
            | Some res =>
                case res as AKEnum {
                    | ClientRequest => () 
                    | TicketResponse sk => 
                        let m' = aenc(sk, username) in
                        let p' = client_to_service_msg(service_ticket, m') in
                        let _ = output p' to endpoint(service) in 
                        // wait for service's response
                        input _ in () 
                    otherwise => ()
                }
        }
    } 
    otherwise ()

def client_kerberos_tmpcopy (ak: if sec(K) then Name(AK) else Data<adv>, tgt :
Data<adv>, username : Data<adv>) @ client
    : Unit = 
    corr_case AK in
    corr_case K in
    let m = aenc(ak, ClientRequest()) in
    let p = client_to_ticketserver_msg(tgt, m) in
    let _ = output p to endpoint(ticketserver) in

    input i' in 
    parse i' as ticketserver_msg(service_ticket, c) in { 
        case adec(ak, c) {
            | None => ()
            | Some res =>
                case res as AKEnum {
                    | ClientRequest => () 
                    | TicketResponse sk => 
                        let m' = aenc(sk, username) in
                        let p' = client_to_service_msg(service_ticket, m') in
                        let _ = output p' to endpoint(service) in 
                        // wait for service's response
                        input _ in () 
                    otherwise => ()
                }
        }
    }
    otherwise ()



def client_pkinit (certC : Data<adv> ||signature||, vkCA : vk(sigkeyCA)) @ client
    requires ([sigkeyA] <= [sigkeyCA]) /\ ([K] <= [sigkeyCA]) /\ ([K] <= [sigkeyA]) /\ (! ([sigkeyA] <= [K]))
    : Unit =

    // make username
    let username = get(uname) in

    // sign username (TODO: sign a timestamp + nonce instead of username)
    let signed_name = sign(get(sigkeyC), username) in

    // output = {{verkeyC}}_CA, verkeyC, {{username}}_sigkeyC, username
    let p = pkinit_client_to_authserver_msg(certC, get_vk(sigkeyC), signed_name, username) in
    let _ = output p to endpoint(authserver) in

    // i = tgt, (AK)_K, msg = {{certA, verkeyA, k, [k]_sigkeyA}}_pubkeyC 
    input tgt in
    input enc_ak in
    input msg in

    // use pke key seckeyC to decrypt msg
    corr_case seckeyCnew in
    case pkdec(get(seckeyCnew), msg) {
        | None => ()
        | Some p' => 
            union_case p = p' in 
            parse p as ClientPKResponse(certA, vka, k, ksig) in { 
             // certA = signature of verkeyA signed by sigkeyCA
             corr_case sigkeyCA in
                 case vrfy(vkCA, certA, vka) {// get verkeyA = vk(sigkeyA)
                    | Some res =>
                        case res {
                          | ClientCert _ => ()
                          | AuthCert vkA => 
                            // now use verkeyA to verify signed_k
                            corr_case sigkeyA in
                            case vrfy(vkA, k, ksig) { // get K, sign(sigkeyA, k)
                                | Some k =>
                                    // finally, decrypt AK using k
                                    corr_case K in
                                    case adec(k, enc_ak) { 
                                        | Some ak =>
                                            call client_kerberos_tmpcopy(ak, tgt, username)
                                        | None => ()
                                    }
                                | None => ()
                            }
                        }
                    | None => ()
                 }
            }
            otherwise ()
    }
                 
    

def client_main () @ client
    : Unit =
    
    let username = get(uname) in
    let _ = output username to endpoint(authserver) in

    // i = tgt, aenc(kC, AK)
    input i in 

    parse i as authserver_msg(tgt, c) in {
        corr_case kC in
        case adec(get(kC), c) {
            | None => ()
            | Some ak =>
                call client_kerberos(ak, tgt, username)
        }
    } otherwise ()


def authserver_main () @ authserver
    : Unit =

    // i = client's username
    input i, _ in 
    if eq(i, get(uname)) then

        // make & send TGT = (AK)_kT, m = (AK)_kC
        let tgt = aenc(get(kT), get(AK)) in

        let m = aenc(get(kC), get(AK)) in
        let p = authserver_msg(tgt, m) in

        let _ = output p to endpoint(client) in ()
    else ()


def ticketserver_main () @ ticketserver
    : Unit =

    // i = (AK)_kT, (ClientRequest)_AK 
    input i in 
    
    corr_case kT in
    parse i as client_to_ticketserver_msg(c, t) in {
    case adec(get(kT), c) {
         | None => ()
         | Some ak =>
         
             corr_case AK in
             case adec(ak, t) {
                 | Some ClientRequest =>
                     let st = aenc(get(kS), get(SK)) in
                     let m = aenc(ak, TicketResponse(get(SK))) in
                     let p = ticketserver_msg(st, m) in
                     let _ = output p to endpoint(client) in ()
                 | None => ()
             }
    }
    }
    otherwise ()


def service_main () @ service
    : Unit =

    // i = (SK)_kS, ("client")_SK
    input i in
    
    corr_case kS in
    parse i as client_to_service_msg(c1, c2) in {
    case adec(get(kS), c1) {
         | None => ()
         | Some sk =>
             corr_case SK in
             case adec(sk, c2) {
                 | None => ()
                 | Some u =>
                     if eq(u, get(uname)) then
                         let _ = output 0 to endpoint(client) in ()
                     else ()
             }
    }
    } 
    otherwise ()

def authserver_pkinit (certA : Data<adv> ||signature||, vkCA : vk(sigkeyCA), pkC : encpk(seckeyCnew)) @ authserver
    requires    ([K] <= [sigkeyC]) /\
                ([K] <= [sigkeyCA])
    : Unit =

    // i = {{verkeyC}}_CA, verkeyC, {{username}}_sigkeyC, username
    input i in 
    parse i as pkinit_client_to_authserver_msg(certC, vkc, signed_un, un) in {
        // check that we got a good certificate
        case certC as CertAuthMsgs {// get client vertificate
             | ClientCert certC =>
             
                 // check that certC is valid for vkC
                corr_case sigkeyCA in
                 case vrfy(vkCA, certC, vkc) { 
                     | None => ()
                     | Some vkC =>
                     
                         // use verkeyC to verify the username
                         corr_case sigkeyC in
                         case vrfy(vkC, signed_un, un) {
                             | None => ()
                             | Some username =>
                             
                                 // signed username is equal to the client we expected
                                 // TODO: check that a signed timestamp is still fresh
                                 if eq(username, get(uname)) then

                                    // sign/encrypt/send outputs to client
                                    let tgt = aenc(get(kT), get(AK)) in
                                    output tgt to endpoint(client);
                                    
                                    let enc_ak = aenc(get(K), get(AK)) in
                                    output enc_ak to endpoint(client);
                                    
                                    // bundle msg and encrypt with pubkeyC
                                    let sA = get(sigkeyA) in
                                    let k''= get(K) in
                                    // let signed_k : Data<adv> ||signature||= sign(sA, k'') in
                                    let signed_k = sign(sA, k'') in
                                    let b = eq(length(signed_k), |signature|) in
                                    if b then
                                        let field1 : Data<adv>||signature|| = certA in 
                                        let field2 : vk(sigkeyA) = get_vk(sigkeyA) in 
                                        let field3 : Name(K) = get(K) in 
                                        // let field4 : Data<adv>||signature|| = signed_k in 
                                        let field4 = signed_k in 
                                        let str : ClientPKResponse = ClientPKResponse(field1, field2, field3, field4) in 
                                        let msg = pkenc(pkC, str) in
                                        output msg to endpoint(client); ()
                                    else ()
                                 else ()
                         }
                 }
              | AuthCert x => ()
              otherwise => ()
        }
    }
    otherwise ()


// not really needed, just to satisfy extraction
def certauth_main () @ certauth : Unit = ()
