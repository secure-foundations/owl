locality client : 1
locality server 
name X<@g> : DH @ client<g>

name Y : DH @ server

name data<@h> : nonce @ client<h>
corr<i> [X<@i>] ==> [data<@i>]
corr<i> [Y] ==> [data<@i>]

odh L<@f> : 
    X<@f>, Y -> {salt info.
        True -> enckey Name(data<@f>)
    }

def client_main<@i>(pky : dhpk(Y)) @ client<i> : Unit = 
    let h = dhpk(get(X<@i>)) in
    output h;
    corr_case X<@i> in 
    corr_case Y in 
    let y = kdf<;odh L<@i>[0]; enckey; 0>(0x, dh_combine(pky, get(X<@i>)), 0x)
    in 
    let c = aenc(y, get(data<@i>)) in 
    output c


def server_getkey() @ server : Option 
(Union<Data<adv>, (exists j. Name(ODHName<L<@j>; 0>(0x, 0x)[0]))>) = 
    input h in 
    if is_group_elem(h) then {
        pcase (exists j:idx. dh_combine(h, get(Y)) == dh_combine(dhpk(get(X<@j>)), get(Y))) in 
        choose_idx j | dh_combine(h, get(Y)) == dh_combine(dhpk(get(X<@j>)), get(Y)) in 
        let ss = dh_combine(h, get(Y)) in 
        corr_case X<@j> in 
        corr_case Y in 
        debug resolveANF(ss);
        let y = kdf<;odh L<@j>[0]; enckey; 0>(0x, ss, 0x) in 
        Some(pack<j>(y))
    }
    else None<type Union<Data<adv>, (exists j. Name(ODHName<L<@j>; 0>(0x,
        0x)[0]))>>()  


def server_main() @ server :
Unit = 
    let u = call server_getkey() in  
    case u {
    | None => ()
    | Some u_ => 
        union_case x_ = u_ in 
        unpack j, x = x_ in 
        input c in 
        corr_case ODHName<L<@j>; 0>(0x, 0x)[0] in 
        case adec(x, c) {
        | Some m => 
            let c = aenc(x, m) in 
            output c
        | None => ()
        }
    }
        




