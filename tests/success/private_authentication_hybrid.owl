/*
* A -> B : aenc(<pkA,n0>,r0,pkB)
* B -> A : aenc(<n0,n>,r,pkA)
*/


locality A
locality B

name n0<i> : nonce @ A, B
name r0<i> : nonce @ A
name n<i> : nonce @ B
name r<i> : nonce @ B

enum m1_pkA_enum {
    | m1_pkA_tag Data<adv>
}

struct m1<i> {
    m1_n0 : Name(n0<i>),
    m1_r0: Name(r0<i>),
    m1_pkA: m1_pkA_enum
}

struct m2<j> {
    m2_n0: Name(n0<j>),
    m2_n : Name(n<j>),
    m2_r: Name(r<j>)
}

name hybrid_skA : enckey (exists i. m1<idx i>) @ A
name hybrid_skB : enckey (exists j. m2<idx j>) @ B

name pkA : pkekey Name(hybrid_skB) @ A
name pkB : pkekey Name(hybrid_skA) @ B

def A_main<i> () @ A
: Unit =
    let hybridKA          = get(hybrid_skA) in
    let enc_hybridKA      =  pkenc(get_encpk(pkB), hybridKA) in
    let _ = output enc_hybridKA to endpoint(B) in
    let m = pack<i>(m1<idx i>(get(n0<i>), get(r0<i>), m1_pkA_tag(get_encpk(pkA)))) in 
    let encm              =  aenc(hybridKA, m) in 
    let _ = output encm to endpoint(B) in

    input enc_hybridKB in
    input inp in
    corr_case pkA in
    case pkdec(get(pkA), enc_hybridKB) {
        | None => ()
        | Some hybridKB =>
            corr_case hybrid_skB in 
            case adec(hybridKB, inp) as Option (exists j. m2<idx j>) {
                | None => ()   
                | Some _ => ()
                otherwise => ()
            }
    }


def B_main<j> () @ B
: Unit =
    let privKey = get(pkB) in
    corr_case pkB in

    input enc_hybridKA in
    input inp in
    case pkdec(privKey, enc_hybridKA) as Option Name(hybrid_skA) {
        | None => ()
        | Some hybridKA => 
            corr_case hybrid_skA in 
            case adec(hybridKA, inp) as Option (exists i. m1<idx i>) {
            | None => ()
            | Some m => {
                unpack i, m' = m in
                parse m' as m1<idx i>(n0', _, m1_pkA_e) in 
                case m1_pkA_e as m1_pkA_enum {
                | m1_pkA_tag m1_pkA =>
                    pcase (i =idx j) in 
                    if eq(m1_pkA, get_encpk(pkA)) && checknonce(n0', get(n0<j>)) then
                        false_elim in 
                        let hybridKB          = get(hybrid_skB) in
                        let enc_hybridKB      =  pkenc(get_encpk(pkA), hybridKB) in
                        let _ = output enc_hybridKB to endpoint(A) in
                        let pubKeyA = get_encpk(pkA) in
                        let m = pack<j>(m2<idx j>(get(n0<j>), get(n<j>), get(r<j>))) in
                        let encm =  aenc(hybridKB, m) in 
                        let _ = output encm to endpoint(A) in
                        ()
                    else ()
                 otherwise => ()
                }
                otherwise ()
            }
            otherwise => ()
        }
                
        otherwise => ()
    }

