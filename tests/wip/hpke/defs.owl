locality sender
locality receiver

name channel_secret : nonce

type plaintext_t = Data<[channel_secret] /\ adv, |adv|>

name skR : DH @ receiver
name skE<i> : DH @ sender
name skS : DH @ sender


counter send_counter<i> @ sender
counter recv_counter<j> @ receiver

/*
secret = Extract(dh_shared_secret, concat("HPKE-v1", suite_id, "secret", psk))
key = Expand(secret, concat(i2osp(Nk, 2), "HPKE-v1", suite_id, "key", key_sched_context), Nk)
base_nonce = Expand(secret, concat(i2osp(Nk, 2), "HPKE-v1", suite_id, "base_nonce", key_sched_context), Nk)
exporter = same but "exp"

kdf(x, y, z) = Expand(Extract(x, y), z; length)

key_schedule_context is a pure function of "info"; so we will leave this as a
constant as well

we will need extra machinery for psk to be valid in concat position;
let's leave it off for now as well

key = hkdf(dh_shared_secret, concat("HPKE-v1", suite_id, "secret", psk), 
    concat(I2OSP(Nk, 2), "HPKE-v1", suite_id, "key", key_schedule_context);
    Nk

base_nonce = hkdf(dh_shared_secret, concat("HPKE-v1", suite_id, "secret", psk), 
    concat(I2OSP(Nk, 2), "HPKE-v1", suite_id, "base_nonce", key_schedule_context);
    Nk
)
*/

func hpke_v1() = 0x48504b452d7631
func suite_id() = 0x1234 // TODO
func secret_string() = 0x736563726574 // "secret"
func shared_secret_string() = 0x7368617265645f736563726574 // "shared_secret"
func key_string() = 0x6b6579 // "key"
func base_nonce_string() = 0x626173655f6e6f6e6365 // "base_nonce"
func export_string() = 0x657870 // "exp"
func info_hash_string() = 0x696e666f5f68617368 // "info_hash"
func psk_id_hash_string() = 0x70736b5f69645f68617368 // "psk_id_hash"
func crh_labeled_extract_0salt(lbl, ikm) = 
    crh(hpke_v1() ++ suite_id() ++ lbl ++ ikm) // crh here = hmac. TODO support 2-place crh

func psk_id() = (0x)

func info() = (0x)

func mode() = 0x03 // auth_psk
func key_schedule_context() = 
    mode() ++ crh_labeled_extract_0salt(info_hash_string(), info()) ++
    crh_labeled_extract_0salt(psk_id_hash_string(), psk_id())

func eae_prk() = 0x6561655f70726b

func lbl_ikm(lbl, ikm) = 
    hpke_v1() ++ suite_id() ++ lbl ++ ikm

func lbl_info(len, lbl, info) = 
    len ++ hpke_v1() ++ suite_id() ++ lbl ++ info

func kdfkey_len() = 
    0x0020

func enckey_len() = 
    0x0020

func base_nonce_kdf_info() = 
    lbl_info(enckey_len(), base_nonce_string(), key_schedule_context())

func key_kdf_info() =                         
    lbl_info(enckey_len(), key_string(), key_schedule_context())

func export_kdf_info() = 
    lbl_info(enckey_len(), export_string(), key_schedule_context())

func dh_secret_kdf_ikm(psk_) = lbl_ikm(secret_string(), psk_)


func AuthEncap_dh<i>() =   
    dh_combine(dhpk(get(skR)), get(skS))
    ++
    dh_combine(dhpk(get(skR)), get(skE<i>))

func AuthEncap_kem_context<i>() =   
    dhpk(get(skE<i>)) 
    ++
    dhpk(get(skR)) 
    ++
    dhpk(get(skS)) 

func AuthEncap_honest_info<i>() = 
    lbl_info(kdfkey_len(), shared_secret_string(), AuthEncap_kem_context<session i>())

func AuthEncap_shared_secret<i>() = 
    gkdf<kdfkey;0>(0x, lbl_ikm(eae_prk(), AuthEncap_dh<session i>()),
                       lbl_info(kdfkey_len(), shared_secret_string(),
                       AuthEncap_kem_context<session i>()))


func AuthDecap_dh(eph) = 
    dh_combine(dhpk(get(skR)), get(skS))
    ++
    dh_combine(eph, get(skR))

func AuthDecap_kem_context(eph) =   
    eph
    ++
    dhpk(get(skR)) 
    ++
    dhpk(get(skS)) 

func AuthDecap_shared_secret(eph) = 
    gkdf<kdfkey;0>(0x, lbl_ikm(eae_prk(), AuthDecap_dh(eph)),
                       lbl_info(kdfkey_len(), shared_secret_string(),
                       AuthDecap_kem_context(eph)))

nametype hpke_corr_key_t = 
     st_aead (x:Data<adv>{false})
          aad x. false
          nonce send_counter


nametype psk_t = dualkdf {salt info self.
    (info == base_nonce_kdf_info()) -> public nonce |counter|,
    (exists i:idx. salt == AuthEncap_shared_secret<session i>()) /\ info == key_kdf_info() -> 
     strict st_aead Data<[channel_secret] /\ adv, |adv|>
                              aad x. true
                              nonce send_counter
                              pattern i. xor(i, gkdf<nonce |counter|;0>(salt,
                                dh_secret_kdf_ikm(self),
                                base_nonce_kdf_info())),
    (forall i:idx. salt != AuthEncap_shared_secret<session i>()) /\ info == key_kdf_info() -> 
         strict hpke_corr_key_t,
    (info == export_kdf_info()) -> strict nonce

}

name psk : psk_t @ sender, receiver

corr<i> [skE<i>] /\ [skS] /\ [psk] ==> [channel_secret]
corr [skR] /\ [psk] ==> [channel_secret]
corr [psk] ==> [channel_secret]


nametype hpke_key_t<i> = 
    st_aead Data<[channel_secret] /\ adv, |adv|>
        aad x. true
        nonce send_counter
        pattern i. xor(i, gkdf<nonce |counter|;0>(AuthEncap_shared_secret<session i>(), 
                                                dh_secret_kdf_ikm(get(psk)),
                                                base_nonce_kdf_info()))



nametype shared_secret_t = 
    kdf {ikm info self. 
        (ikm == dh_secret_kdf_ikm(get(psk)))
        /\
        info == base_nonce_kdf_info()
        -> public nonce |counter|,

        (ikm == dh_secret_kdf_ikm(get(psk)))
        /\
        info == key_kdf_info()
        -> strict st_aead Data<[channel_secret] /\ adv, |adv|>
                          aad x. true
                          nonce send_counter
                          pattern i. xor(i, gkdf<nonce |counter|;0>(self,
                          dh_secret_kdf_ikm(get(psk)), base_nonce_kdf_info())),

        (ikm == dh_secret_kdf_ikm(get(psk)))
        /\
        info == export_kdf_info()
        -> strict nonce
    }

nametype shared_secret_corr_t = 
    kdf {ikm info self. 
        (ikm == dh_secret_kdf_ikm(get(psk)))
        /\
        info == base_nonce_kdf_info()
        -> public nonce |counter|,

        (ikm == dh_secret_kdf_ikm(get(psk)))
        /\
        info == key_kdf_info()
        -> strict hpke_corr_key_t,

        (ikm == dh_secret_kdf_ikm(get(psk)))
        /\
        info == export_kdf_info()
        -> strict nonce
    }


odh ss : skR, skS -> { salt info. 
    (exists i:idx. info == AuthEncap_honest_info<session i>()) -> strict shared_secret_t,
    (forall i:idx. info != AuthEncap_honest_info<session i>()) -> strict shared_secret_corr_t
} 

odh se<i> : skR, skE<i> -> {salt info.
    (info == AuthEncap_honest_info<session i>()) -> strict shared_secret_t,
    (info != AuthEncap_honest_info<session i>()) -> strict shared_secret_corr_t
}
