include "defs.owl"

/*
struct AuthDecapResult<i> {
    adr_eph : (x:Ghost{is_group_elem(x) /\ (x == dhpk(get(skE<i>)) \/ (forall j:idx. x != dhpk(get(skE<j>))))}), 
    adr_shared_secret : 
        if adr_eph == dhpk(get(skE<i>)) /\ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))) then
            SecName(KDF<kdfkey;0;shared_secret_t>(0x, 
            lbl_ikm(kem_suite_id(), eae_prk(), AuthDecap_dh(adr_eph)), 
            lbl_info(kem_suite_id(), kdfkey_len(), shared_secret_string(), AuthDecap_kem_context(adr_eph))))
        else if sec(skR) /\ sec(skS) then 
            SecName(KDF<kdfkey;0;shared_secret_corr_t>(0x, 
            lbl_ikm(kem_suite_id(), eae_prk(), AuthDecap_dh(adr_eph)), 
            lbl_info(kem_suite_id(), kdfkey_len(), shared_secret_string(), AuthDecap_kem_context(adr_eph))))
        else
            (x:Data<adv> ||kdfkey|| {
                x == AuthDecap_shared_secret(adr_eph) 
                }),
    adr_shared_secret_inj : (x:Ghost{
            (adr_eph == dhpk(get(skE<i>)) <==> adr_shared_secret == AuthEncap_shared_secret<session i>())
            /\
            (adr_eph != dhpk(get(skE<i>)) ==> (forall j:idx. adr_shared_secret != AuthEncap_shared_secret<session j>()))
            })
}

*/

struct AuthDecapResult<i> {
    adr_ss  : Ghost,
    adr_info  : Ghost,
    adr_eph : (x:Ghost{is_group_elem(x) /\ (x == dhpk(get(skE<i>)) \/ (forall j:idx. x != dhpk(get(skE<j>))))}), 
    adr_shared_secret : 
        if secret_dh_unauth<i>[adr_eph] then 
                SecName(Expand<extractkey; 0; secret_extract_t>(adr_ss,
                adr_info))
        else Data<adv>
}



def AuthDecap(pkS : dhpk(skS), pkR: dhpk(skR), eph : Data<adv>) @ receiver :
Option (exists i.AuthDecapResult<session i>) = 
    guard is_group_elem(eph) in         
    pcase (exists i:idx. eph == dhpk(get(skE<i>))) in
    pcase (eph == dhpk(get(skS))) when (! (exists i:idx. eph == dhpk(get(skE<i>)))) in 
    choose_idx i | eph == dhpk(get(skE<i>)) in 
    corr_case skE<i> when (exists i:idx. eph == dhpk(get(skE<i>)))  in
    corr_case skR in 
    let dh = dh_combine(eph, get(skR)) ++ dh_combine(pkS, get(skR))  in
    let kem_context = eph ++ pkR ++ pkS in
    let shared_secret_ext = extract<ss, se<i>>(0x, labeled_ikm("eae_prk", dh)) in 
    let info = labeled_info("shared_secret", kem_context, kdfkey_len()) in 
    let shared_secret = expand<0; extractkey;0>(shared_secret_ext,
    info) in
    let res = AuthDecapResult<session i>(shared_secret_ext, info, eph,
    shared_secret) in
    let pres = pack<i>(res) in
    Some(pres)


predicate correct_eph(x) = (exists i:idx. x == dhpk(get(skE<i>)))

struct ContextR<i> {
    ctxtR_eph : (x:Ghost{is_group_elem(x) /\ (x == dhpk(get(skE<i>)) \/ (forall j:idx. x != dhpk(get(skE<j>))))}), 
    ctxtR_secret : Ghost,
    ctxtR_kss    : Ghost,
    ctxtR_base : 
        if sec(psk) \/ secret_dh_unauth<i>[ctxtR_eph] then 
                PubName(Expand<nonce |counter|; 0; nonce
                    |counter|>(ctxtR_secret, labeled_info("base_nonce", ctxtR_kss, nonce_len())))
        else
            Data<adv>,
    ctxtR_key : 
        if sec(psk) \/ secret_dh_unauth<i>[ctxtR_eph] then 
            SecName(Expand<enckey; 0; plaintext_enc_t(ctxtR_secret, base_info(ctxtR_kss))>(ctxtR_secret, key_info(ctxtR_kss)))
        else
        Data<adv>,
    ctxtR_exp : 
        if sec(psk) \/ secret_dh_unauth<i>[ctxtR_eph] then 
                SecName(Expand<nonce; 0; nonce>(ctxtR_secret, exp_info(ctxtR_kss)))
        else
            Data<adv>
}

def KeyScheduleR(adr : exists i. AuthDecapResult<session i>) @ receiver : exists i. ContextR<session i> = 
    unpack i, adr' = adr in 
    parse adr' as AuthDecapResult<session i>(_, _, eph, shared_secret) in 
    pcase (eph == dhpk(get(skE<i>))) in 
    let psk_id_hash = extract(0x, labeled_ikm("psk_id_hash", psk_id())) in 
    let info_hash =   extract(0x, labeled_ikm("info_hash", info()))     in 
    let kss       =   mode() ++ psk_id_hash ++ info_hash in 
    assert (length(kss) == 1 + 2 * |expandkey|);
    let secret    =   extract(shared_secret, labeled_ikm("secret", get(psk))) in 
    let base_nonce = expand<0(kss); nonce |counter|; 0>(secret, labeled_info("base_nonce", kss, nonce_len())) in 
    let key =   expand<1(kss); enckey; 0>(secret, labeled_info("key", kss, enckey_len())) in 
    let exp =   expand<2(kss); nonce; 0>(secret,  labeled_info("exp", kss, nonce_len()))  in 
    let res = ContextR<session i>(eph, secret, kss, base_nonce, key, exp) in 
    pack<i>(res)

struct OpenMsg {
    om_eph : Ghost,
    om_aad : (x:Ghost{(sec(psk) \/ (exists i:idx. secret_dh_unauth<i>[om_eph])) ==> happened(sent_message_aad(x))}),
    om_m   : (x:Data<adv /\ [channel_secret], |adv|>{
               (sec(psk) \/ (exists i:idx. secret_dh_unauth<i>[om_eph])) ==>
               happened(sent_message(x))})
}


def Open<j>(ctxtR : exists i. ContextR<session i>, ct_aad : Data<adv>, ct : Data<adv>) @ receiver : Option OpenMsg = 
    unpack i, ctxtR = ctxtR in 
    parse ctxtR as ContextR<session i>(eph, _, _, bn, sk, exp) in
    let ctr = get_counter recv_counter<j> in 
    let iv = xor(bn, ctr) in
    inc_counter recv_counter<j>;
    case st_aead_dec(sk, ct, ct_aad, iv) as Option Data<[channel_secret] /\ adv, |adv|> {
        | Some x =>
            assert (sec(psk) \/ secret_dh_unauth<i>[eph] ==> happened(sent_message(x)));
            Some(OpenMsg(eph, ct_aad, x))
        | None => None()
        otherwise => None()
    }


def SingleShotOpen<j>(pkS : dhpk(skS), pkR : dhpk(skR)) @ receiver : Option OpenMsg = 
    input i in 
    parse i as hpke_ciphertext(eph, ct) in {
        let oadr = call AuthDecap(pkS, pkR, eph) in
        case oadr {
            | Some adr => {
                let ctxt = call KeyScheduleR(adr) in
                call Open<j>(ctxt, 0x, ct)
              }
            | None => None()
        }
    }
    otherwise None()


