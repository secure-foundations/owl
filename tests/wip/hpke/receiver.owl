include "defs.owl"

struct AuthDecapResult<i> {
    adr_eph : (x:Ghost{is_group_elem(x) /\ (x == dhpk(get(skE<i>)) \/ (forall j:idx. x != dhpk(get(skE<j>))))}), 
    adr_shared_secret : 
        if adr_eph == dhpk(get(skE<i>)) /\ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))) then
            SecName(KDF<kdfkey;0;shared_secret_t>(0x, 
            lbl_ikm(eae_prk(), AuthDecap_dh(adr_eph)), 
            lbl_info(kdfkey_len(), shared_secret_string(), AuthDecap_kem_context(adr_eph))))
        else if sec(skR) /\ sec(skS) then 
            SecName(KDF<kdfkey;0;shared_secret_corr_t>(0x, 
            lbl_ikm(eae_prk(), AuthDecap_dh(adr_eph)), 
            lbl_info(kdfkey_len(), shared_secret_string(), AuthDecap_kem_context(adr_eph))))
        else
            (x:Data<adv> ||kdfkey|| {
                x == AuthDecap_shared_secret(adr_eph) 
                }),
    adr_shared_secret_inj : (x:Ghost{
            (adr_eph == dhpk(get(skE<i>)) <==> adr_shared_secret == AuthEncap_shared_secret<session i>())
            /\
            (adr_eph != dhpk(get(skE<i>)) ==> (forall j:idx. adr_shared_secret != AuthEncap_shared_secret<session j>()))
            })
}

def AuthDecap(pkS : dhpk(skS), eph : Data<adv>) @ receiver : Option (exists i.AuthDecapResult<session i>) = 
    guard is_group_elem(eph) in         
    pcase (exists i:idx. eph == dhpk(get(skE<i>))) in 
    pcase (eph == dhpk(get(skS))) when (! (exists i:idx. eph == dhpk(get(skE<i>)))) in 
    choose_idx i | eph == dhpk(get(skE<i>)) in 
    let dh = dh_combine(pkS, get(skR)) ++ dh_combine(eph, get(skR)) in
    let kem_context = eph ++ dhpk(get(skR)) ++ pkS in
    let shared_secret = kdf<; odh ss[0], odh ss[1], odh se<i>[0], odh se<i>[1];kdfkey;0>(0x,
        lbl_ikm(eae_prk(), dh), 
        lbl_info(kdfkey_len(), shared_secret_string(), kem_context)) in
    let shared_secret_ghost = gkdf<kdfkey;0>(0x,
        lbl_ikm(eae_prk(), dh), 
        lbl_info(kdfkey_len(), shared_secret_string(), kem_context)) in
    forall j:idx {
        kdf_inj_lemma(shared_secret_ghost, AuthEncap_shared_secret<session j>())
    };
    Some(AuthDecapResult<session i>(eph, shared_secret, ()))

    
struct ContextR<i> {
        ctxtR_eph : (x:Ghost{is_group_elem(x) /\ (x == dhpk(get(skE<i>)) \/ (forall j:idx. x != dhpk(get(skE<j>))))}), 
        ctxtR_confirmed : Bool<adv>,
        ctxtR_ss : (x:Ghost{x == AuthDecap_shared_secret(ctxtR_eph)}),
        ctxtR_base : 
        if (sec(psk) \/ (sec(skR) /\ (sec(skS) \/ (ctxtR_eph == dhpk(get(skE<i>)) /\ sec(skE<i>)))))
            then PubName(KDF<nonce |counter|;0;nonce |counter|>(ctxtR_ss,
            dh_secret_kdf_ikm(get(psk)), base_nonce_kdf_info()))
            else Data<adv>,
        ctxtR_sk :
        if ctxtR_eph == dhpk(get(skE<i>)) /\ (sec(psk) \/ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))))
            then SecName(KDF<enckey;0;hpke_key_t<i>>(ctxtR_ss,
            dh_secret_kdf_ikm(get(psk)), key_kdf_info()))
            else 
                if (ctxtR_confirmed == false) /\ (sec(psk) \/ (sec(skR) /\ sec(skS)))
                    then SecName(KDF<enckey;0;hpke_corr_key_t>(ctxtR_ss, dh_secret_kdf_ikm(get(psk)), key_kdf_info()))
                else
                    Data<adv>,
        ctxtR_export : 
        if (sec(psk) \/ (sec(skR) /\ (sec(skS) \/ (ctxtR_eph == dhpk(get(skE<i>)) /\ sec(skE<i>)))))
            then SecName(KDF<nonce;0;nonce>(ctxtR_ss,
            dh_secret_kdf_ikm(get(psk)), export_kdf_info()))
            else Data<adv>
}

def KeyScheduleR(adr : exists i. AuthDecapResult<session i>) @ receiver : exists i. ContextR<session i> = 
    unpack i, adr' = adr in 
    parse adr' as AuthDecapResult<session i>(eph, shared_secret, _) in 
    pcase (eph == dhpk(get(skE<i>))) in 
    let base_nonce = kdf<0;0;nonce |counter|;0>(shared_secret, dh_secret_kdf_ikm(get(psk)), base_nonce_kdf_info()) in 
    assert (eph != dhpk(get(skE<i>)) ==> shared_secret != AuthEncap_shared_secret<session i>());
    assert (eph != dhpk(get(skE<i>)) ==> (forall j:idx. shared_secret != AuthEncap_shared_secret<session j>()));
    let sk = kdf<1;1,2;enckey;0>(shared_secret, dh_secret_kdf_ikm(get(psk)), key_kdf_info()) in 
    let exp = kdf<2;3;nonce;0>(shared_secret, dh_secret_kdf_ikm(get(psk)), export_kdf_info()) in 
    let res : ContextR<session i> = ContextR<session i>(eph, false, shared_secret, base_nonce, sk, exp) in
    pack<i>(res)


enum OpenMsg { 
    | SomeMsg plaintext_t
    | NoMsg
}

struct OpenResult<i> {
    or_ctxt : ContextR<session i>,
    or_pt : OpenMsg,
    or_wf : (x:Ghost{SomeMsg?(or_pt) ==> ctxtR_confirmed<session i>(or_ctxt) == true})
}

def Open<j>(ctxtR : exists i. ContextR<session i>, ct_aad : Data<adv>, ct : Data<adv>) @ receiver : exists i. OpenResult<session i> = 
    unpack i, ctxtR = ctxtR in 
    parse ctxtR as ContextR<session i>(eph, confirmed, ss, bn, sk, exp) in
    let ctr = get_counter recv_counter<j> in 
    inc_counter recv_counter<j>;
    pcase (eph == dhpk(get(skE<i>))) in 
    case st_aead_dec(sk, ct, ct_aad, ctr) as Option Data<[channel_secret] /\ adv, |adv|> {
        | Some x =>
            false_elim in 
            let ctxtR' = ContextR<session i>(eph, true, ss, bn, sk, exp) in 
            let res = OpenResult<session i>(ctxtR', SomeMsg(x), ()) in
            pack<i>(res)
        | None => let res = OpenResult<session i>(ctxtR, NoMsg(), ()) in pack<i>(res)
        otherwise => let res = OpenResult<session i>(ctxtR, NoMsg(), ()) in pack<i>(res)
    }

def SingleShotOpen<j>(pkS : dhpk(skS), eph : Data<adv>, ct_aad : Data<adv>, ct:Data<adv>) @ receiver : Option (exists i. OpenResult<session i>) =
    let oadr = call AuthDecap(pkS, eph) in
    case oadr {
        | Some adr => {
            let ctxt = call KeyScheduleR(adr) in
            let res = call Open<j>(ctxt, ct_aad, ct)  in
            Some(res)
          }
        | None => None()
    }
    

    

