include "defs.owl"

/*
struct AuthDecapResult<i> {
    adr_eph : (x:Ghost{is_group_elem(x) /\ (x == dhpk(get(skE<i>)) \/ (forall j:idx. x != dhpk(get(skE<j>))))}), 
    adr_shared_secret : 
        if adr_eph == dhpk(get(skE<i>)) /\ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))) then
            SecName(KDF<kdfkey;0;shared_secret_t>(0x, 
            lbl_ikm(kem_suite_id(), eae_prk(), AuthDecap_dh(adr_eph)), 
            lbl_info(kem_suite_id(), kdfkey_len(), shared_secret_string(), AuthDecap_kem_context(adr_eph))))
        else if sec(skR) /\ sec(skS) then 
            SecName(KDF<kdfkey;0;shared_secret_corr_t>(0x, 
            lbl_ikm(kem_suite_id(), eae_prk(), AuthDecap_dh(adr_eph)), 
            lbl_info(kem_suite_id(), kdfkey_len(), shared_secret_string(), AuthDecap_kem_context(adr_eph))))
        else
            (x:Data<adv> ||kdfkey|| {
                x == AuthDecap_shared_secret(adr_eph) 
                }),
    adr_shared_secret_inj : (x:Ghost{
            (adr_eph == dhpk(get(skE<i>)) <==> adr_shared_secret == AuthEncap_shared_secret<session i>())
            /\
            (adr_eph != dhpk(get(skE<i>)) ==> (forall j:idx. adr_shared_secret != AuthEncap_shared_secret<session j>()))
            })
}

*/

struct AuthDecapResult<i> {
    adr_ss  : Ghost,
    adr_info  : Ghost,
    adr_eph : (x:Ghost{is_group_elem(x) /\ (x == dhpk(get(skE<i>)) \/ (forall j:idx. x != dhpk(get(skE<j>))))}), 
    adr_shared_secret : 
        if adr_eph == dhpk(get(skE<i>)) then
            if secret_dh<i>[] then
                SecName(Expand<extractkey; 0; secret_extract_t>(adr_ss,
                adr_info))
            else Data<adv>
        else Data<adv>
}



def AuthDecap(pkS : dhpk(skS), pkR: dhpk(skR), eph : Data<adv>) @ receiver :
Option (exists i.AuthDecapResult<session i>) = 
    guard is_group_elem(eph) in         
    pcase (exists i:idx. eph == dhpk(get(skE<i>))) in
    pcase (eph == dhpk(get(skS))) when (! (exists i:idx. eph == dhpk(get(skE<i>)))) in 
    choose_idx i | eph == dhpk(get(skE<i>)) in 
    corr_case skE<i> when (exists i:idx. eph == dhpk(get(skE<i>)))  in
    corr_case skR in 
    let dh = dh_combine(eph, get(skR)) ++ dh_combine(pkS, get(skR))  in
    let kem_context = eph ++ pkR ++ pkS in
    let shared_secret_ext 
    /*
        : if eph == dhpk(get(skE<i>)) then
            if secret_dh<i>[] then
                SecName(Extract<dh_shared_secret_expand_t>(0x, labeled_ikm("eae_prk", dh)))
            else Data<adv>
        else 
            if sec(skS) /\ sec(skR) then 
                SecName(Extract<dh_shared_secret_expand_t>(0x, labeled_ikm("eae_prk", dh)))
            else
                Data<adv>
                */
    = extract<ss, se<i>>(0x, labeled_ikm("eae_prk", dh)) in 
    let info = labeled_info("shared_secret", kem_context, kdfkey_len()) in 
    let shared_secret = expand<0,1; extractkey;0>(shared_secret_ext,
    info) in
    let res = AuthDecapResult<session i>(shared_secret_ext, info, eph,
    shared_secret) in
    let pres = pack<i>(res) in
    Some(pres)

    /*
    let shared_secret = kdf<; odh ss[0], odh ss[1], odh se<i>[0], odh se<i>[1];kdfkey;0>(0x,
        lbl_ikm(kem_suite_id(), eae_prk(), dh), 
        lbl_info(kem_suite_id(), kdfkey_len(), shared_secret_string(), kem_context)) in
    let shared_secret_ghost = gkdf<kdfkey;0>(0x,
        lbl_ikm(kem_suite_id(), eae_prk(), dh), 
        lbl_info(kem_suite_id(), kdfkey_len(), shared_secret_string(), kem_context)) in
    forall j:idx {
        kdf_inj_lemma(shared_secret_ghost, AuthEncap_shared_secret<session j>())
    };
    let res = AuthDecapResult<session i>(eph, shared_secret, ()) in
    let pres = pack<i>(res) in 
    Some(pres)

    
struct ContextR<i> {
        ctxtR_eph : (x:Ghost{is_group_elem(x) /\ (x == dhpk(get(skE<i>)) \/ (forall j:idx. x != dhpk(get(skE<j>))))}), 
        ctxtR_confirmed : Bool<adv>,
        ctxtR_ss : (x:Ghost{x == AuthDecap_shared_secret(ctxtR_eph)}),
        ctxtR_base : 
        if (sec(psk) \/ (sec(skR) /\ (sec(skS) \/ (ctxtR_eph == dhpk(get(skE<i>)) /\ sec(skE<i>)))))
            then PubName(KDF<nonce |counter|;0;nonce |counter|>(ctxtR_ss,
            dh_secret_kdf_ikm(get(psk)), base_nonce_kdf_info()))
            else Data<adv>,
        ctxtR_sk :
        if ctxtR_eph == dhpk(get(skE<i>)) /\ (sec(psk) \/ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))))
            then SecName(KDF<enckey;0;hpke_key_t<i>>(ctxtR_ss,
            dh_secret_kdf_ikm(get(psk)), key_kdf_info()))
            else 
                if (ctxtR_confirmed == false) /\ (sec(psk) \/ (sec(skR) /\ sec(skS)))
                    then SecName(KDF<enckey;0;hpke_corr_key_t>(ctxtR_ss, dh_secret_kdf_ikm(get(psk)), key_kdf_info()))
                else
                    Data<adv>,
        ctxtR_export : 
        if (sec(psk) \/ (sec(skR) /\ (sec(skS) \/ (ctxtR_eph == dhpk(get(skE<i>)) /\ sec(skE<i>)))))
            then SecName(KDF<nonce;0;nonce>(ctxtR_ss,
            dh_secret_kdf_ikm(get(psk)), export_kdf_info()))
            else Data<adv>
}

def KeyScheduleR(adr : exists i. AuthDecapResult<session i>) @ receiver : exists i. ContextR<session i> = 
    unpack i, adr' = adr in 
    parse adr' as AuthDecapResult<session i>(eph, shared_secret, _) in 
    pcase (eph == dhpk(get(skE<i>))) in 
    let base_nonce = kdf<0;0;nonce |counter|;0>(shared_secret, dh_secret_kdf_ikm(get(psk)), base_nonce_kdf_info()) in 
    assert (eph != dhpk(get(skE<i>)) ==> shared_secret != AuthEncap_shared_secret<session i>());
    assert (eph != dhpk(get(skE<i>)) ==> (forall j:idx. shared_secret != AuthEncap_shared_secret<session j>()));
    let sk = kdf<1;1,2;enckey;0>(shared_secret, dh_secret_kdf_ikm(get(psk)), key_kdf_info()) in 
    let exp = kdf<2;3;nonce;0>(shared_secret, dh_secret_kdf_ikm(get(psk)), export_kdf_info()) in 
    let res : ContextR<session i> = ContextR<session i>(eph, false, shared_secret, base_nonce, sk, exp) in
    pack<i>(res)


enum OpenMsg { 
    | SomeMsg Data<adv /\ [channel_secret], |adv|>
    | NoMsg
}

struct OpenResult<i> {
    or_ctxt : ContextR<session i>,
    or_pt : OpenMsg,
    or_wf : (x:Ghost{SomeMsg?(or_pt) ==> ctxtR_confirmed<session i>(or_ctxt) == true})
}

def Open<j>(ctxtR : exists i. ContextR<session i>, ct_aad : Data<adv>, ct : Data<adv>) @ receiver : exists i. OpenResult<session i> = 
    unpack i, ctxtR = ctxtR in 
    parse ctxtR as ContextR<session i>(eph, confirmed, ss, bn, sk, exp) in
    let ctr = get_counter recv_counter<j> in 
    let iv = xor(bn, ctr) in
    inc_counter recv_counter<j>;
    pcase (eph == dhpk(get(skE<i>))) in 
    case st_aead_dec(sk, ct, ct_aad, iv) as Option Data<[channel_secret] /\ adv, |adv|> {
        | Some x =>
            false_elim in 
            let ctxtR' = ContextR<session i>(eph, true, ss, bn, sk, exp) in 
            assert (eph == dhpk(get(skE<i>)) /\ (sec(psk) \/ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))))) ==> happened(sent_message(x));
            let res : OpenResult<session i> = OpenResult<session i>(ctxtR', SomeMsg(x), ()) in
            pack<i>(res)
        | None => let res = OpenResult<session i>(ctxtR, NoMsg(), ()) in pack<i>(res)
        otherwise => let res = OpenResult<session i>(ctxtR, NoMsg(), ()) in pack<i>(res)
    }


def SingleShotOpen<j>(pkS : dhpk(skS), pkR : dhpk(skR)) @ receiver : Option (exists i. OpenResult<session i>) =
    input i in 
    parse i as hpke_ciphertext(eph, ct) in {
        let oadr = call AuthDecap(pkS, pkR, eph) in
        case oadr {
            | Some adr => {
                let ctxt = call KeyScheduleR(adr) in
                let res = call Open<j>(ctxt, 0x, ct)  in
                Some(res)
              }
            | None => None()
        }
    }
    otherwise None()

    

    

*/
