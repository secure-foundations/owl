include "defs.owl"

struct AuthEncapResult<i> {
    aer_shared_secret : if sec(skR) /\ (sec(skS) \/ sec(skE<i>)) then
        SecName(KDF<kdfkey;0;shared_secret_t>(0x, 
        lbl_ikm(eae_prk(), AuthEncap_dh<session i>()), 
        lbl_info(kdfkey_len(), shared_secret_string(), AuthEncap_kem_context<session i>())))
        else
            (x:Data<adv> ||kdfkey|| {
                x == AuthEncap_shared_secret<session i>()}),
    aer_pke : dhpk(skE<i>)
}

def AuthEncap<i>(pkR : dhpk(skR)) @ sender : AuthEncapResult<session i> = 
    let dh = dh_combine(pkR, get(skS)) ++ dh_combine(pkR, get(skE<i>)) in 
    let kem_context = dhpk(get(skE<i>)) ++ pkR ++ dhpk(get(skS)) in
    let shared_secret = kdf<; odh ss[0], odh se<i>[0];kdfkey;0>(0x,
    lbl_ikm(eae_prk(), dh), lbl_info(kdfkey_len(), shared_secret_string(),
    kem_context)) in
    let res :   if sec(skR) /\ (sec(skS) \/ sec(skE<i>)) then
        SecName(KDF<kdfkey;0;shared_secret_t>(0x, 
        lbl_ikm(eae_prk(), AuthEncap_dh<session i>()), 
        lbl_info(kdfkey_len(), shared_secret_string(), AuthEncap_kem_context<session i>())))
        else
            Data<adv> ||kdfkey||
            = shared_secret in 
    AuthEncapResult<session i>(shared_secret, dhpk(get(skE<i>)))


struct ContextS<i> {
        ctxtS_ss : (x:Ghost{x == AuthEncap_shared_secret<session i>()}),
        ctxtS_base : if sec(psk) \/ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))) 
            then PubName(KDF<nonce |counter|;0;nonce |counter|>(ctxtS_ss,
            dh_secret_kdf_ikm(get(psk)), base_nonce_kdf_info()))
            else Data<adv>,
        ctxtS_sk :
        if sec(psk) \/ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))) 
            then SecName(KDF<enckey;0;hpke_key_t<i>>(ctxtS_ss,
            dh_secret_kdf_ikm(get(psk)), key_kdf_info()))
            else Data<adv>,
        ctxtS_export : 
        if sec(psk) \/ (sec(skR) /\ (sec(skS) \/ sec(skE<i>))) 
            then SecName(KDF<nonce;0;nonce>(ctxtS_ss,
            dh_secret_kdf_ikm(get(psk)), export_kdf_info()))
            else Data<adv>
}

def KeyScheduleS<i>(aer : AuthEncapResult<session i>) @ sender : ContextS<session i> = 
    parse aer as AuthEncapResult<session i>(shared_secret, pkE) in 
    let base_nonce = kdf<0;0;nonce |counter|;0>(shared_secret,
    dh_secret_kdf_ikm(get(psk)), base_nonce_kdf_info()) in 
    let sk = kdf<1;1;enckey;0>(shared_secret, dh_secret_kdf_ikm(get(psk)), key_kdf_info()) in 
    let exp = kdf<2;3;nonce;0>(shared_secret, dh_secret_kdf_ikm(get(psk)), export_kdf_info()) in 
    ContextS<session i>(shared_secret, base_nonce, sk, exp)

def Seal<i>(ctxt : ContextS<session i>, x : Data<[channel_secret] /\ adv, |adv|>) @ sender : Data<adv> = 
    parse ctxt as ContextS<session i>(_, base, sk, _) in 
    st_aead_enc<send_counter<i>, pattern i. xor(i, base)>(sk, x, 0x) 

def SingleShotSeal<i>(pkR : dhpk(skR), x : Data<[channel_secret] /\ adv, |adv|>) @ sender : Unit = 
    let aer = call AuthEncap<i>(pkR) in
    let context = call KeyScheduleS<i>(aer) in 
    let c = call Seal<i>(context, x) in 
    parse aer as AuthEncapResult<session i>(_, pk) in 
    output (pk ++ c) to endpoint(receiver)

