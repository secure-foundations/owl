include "defs.owl"

predicate secret_dh<i>() = sec(skR) /\ (sec(skS) \/ sec(skE<i>)) 
predicate secret_psk_or_dh<i>() = sec(psk) \/ secret_dh<i>[]

struct AuthEncapResult<i> {
    aer_ss : Ghost, 
    aer_info : Ghost, 
    aer_pke : dhpk(skE<i>),
    aer_shared_secret : if sec(skR) /\ (sec(skS) \/ sec(skE<i>)) then
        SecName(Expand<extractkey; 0; secret_extract_t>(aer_ss, aer_info))
        else Data<adv> ||extractkey||
}


def AuthEncap<i>(pkR : dhpk(skR), dhpk_skE: dhpk(skE<i>), dhpk_skS: dhpk(skS)) @ sender : AuthEncapResult<session i> = 
    let dh = dh_combine(pkR, get(skE<i>)) ++ dh_combine(pkR, get(skS))  in 
    let kem_context = dhpk_skE ++ pkR ++ dhpk_skS in
    let shared_secret_ext = extract<ss, se<i>>(0x, labeled_ikm("eae_prk", dh)) in 
    assert (length(kem_context) == 3 * |group|);
    let info = labeled_info("shared_secret", kem_context, kdfkey_len()) in
    let shared_secret = expand<0(kem_context); extractkey; 0>(shared_secret_ext, info) in 
    AuthEncapResult<session i>(shared_secret_ext, info, dhpk_skE, shared_secret)


struct ContextS<i> {
    ctxtS_key_schedule_ctxt : Ghost, 
    ctxtS_secret : Ghost, 
    ctxtS_base : if secret_psk_or_dh<i>[] then
        PubName(Expand<nonce |counter|; 0; nonce |counter|>(ctxtS_secret,
            base_info(ctxtS_key_schedule_ctxt)))
        else
            Data<adv>,
    ctxtS_key : if secret_psk_or_dh<i>[] then
        SecName(Expand<enckey; 0; 
            plaintext_enc_t(ctxtS_secret, base_info(ctxtS_key_schedule_ctxt))>(
            ctxtS_secret, key_info(ctxtS_key_schedule_ctxt))) 
        else
            Data<adv>, 
    ctxtS_exp : if secret_psk_or_dh<i>[] then
        SecName(Expand<nonce; 0; nonce>(ctxtS_secret,
            exp_info(ctxtS_key_schedule_ctxt)))
        else
            Data<adv>
}

def KeyScheduleS<i>(aer : AuthEncapResult<session i>) @ sender : ContextS<session i> = 
    parse aer as AuthEncapResult<session i>(ss_pre, info_pre, pke, shared_secret) in 
    let psk_id_hash = extract(0x, labeled_ikm("psk_id_hash", psk_id())) in 
    let info_hash =   extract(0x, labeled_ikm("info_hash", info()))     in 
    let kss       =   mode() ++ psk_id_hash ++ info_hash in 
    let secret    =   extract(shared_secret, labeled_ikm("secret", get(psk))) in 
    assert (length(kss) == 1 + 2 * |expandkey|);
    let base_nonce       =   expand<0(kss); nonce |counter|; 0>(secret, labeled_info("base_nonce", kss, nonce_len())) in 
    let key =   expand<1(kss); enckey; 0>(secret, labeled_info("key", kss, enckey_len())) in 
    let exp =   expand<2(kss); nonce; 0>(secret,  labeled_info("exp", kss,
    nonce_len()))  in 
    ContextS<session i>(kss, secret, base_nonce, key, exp)

def sent_message(x : Ghost) @ sender : Unit = ()

def Seal<i>(ctxt : ContextS<session i>, x : Data<[channel_secret] /\ adv, |adv|>) @ sender : Data<adv> = 
    pcase secret_psk_or_dh<i>[] in 
    parse ctxt as ContextS<session i>(f, g, base, sk, h) in 
    assert (secret_psk_or_dh<i>[] ==> base == gexpand<nonce |counter|; 0>(g, base_info(f))); 
    call sent_message(x);
    st_aead_enc<send_counter<i>, pattern i. xor(i, base)>(sk, x, 0x) 

def SingleShotSeal<i>(pkR : dhpk(skR), dhpk_skE: dhpk(skE<i>), dhpk_skS: dhpk(skS), x : Data<[channel_secret] /\ adv, |adv|>) @ sender : Unit = 
    let aer = call AuthEncap<i>(pkR, dhpk_skE, dhpk_skS) in
    let context = call KeyScheduleS<i>(aer) in 
    let c = call Seal<i>(context, x) in 
    parse aer as AuthEncapResult<session i>(_, _, pk, _) in 
    output hpke_ciphertext(pk, c) to endpoint(receiver)
