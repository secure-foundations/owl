locality alice
locality bob
name K : nonce @ alice, bob
name N : nonce @ alice
corr adv ==> [N] // secrecy of N doesn't matter

name roKN : RO get(K) || get(N) -> enckey (x:Data<adv>{x == 0x00})

def alice_main() @ alice : Unit =
    let K2 = hash<roKN>(get(K), get(N)) in
    let c = aenc(K2, 0x00) in
    let _ = output get(N) in
    output c

def bob_main() @ bob 
    requires sec(K)
    : Option(Name(roKN)) =
    input N' in
    input c in
    pcase (N' == get(N)) in
    corr_case roKN when N' == get(N) in
    let K2 = hash<roKN>(get(K), N') in
    case adec(K2, c)
    | None => None<ty:Name(roKN)>()
    | Some p =>
        guard (eq(p, 0x00)) in 
        Some(K2)

/* 
    N' : Data<adv>
    c : Data<adv>
    K2 : x:(Data<adv>){ro(concat(get(K), N', 0)) /\ length(x) == |enckey|}

    p : Data<adv>
    _ : eq(p, 0x00)

    The issue is K2 : Data<adv>. This says that K2 is safe to disclose to the
    adv, but in this case, we want to maintain its underivability.
*/

    
        


