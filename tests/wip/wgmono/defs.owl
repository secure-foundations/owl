
/*

type := 0x1 (1 byte) 
reserved := 0^3 (3 bytes)
sender := I_i (4 bytes)
ephemeral (32 bytes)
static (32 bytes)
timestamp (12 bytes)
mac1 (16 bytes) 
mac2 (16 bytes)

CONSTANTS:
construction -> Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s
identifier -> WireGuard v1 zx2c4 Jason@zx2c4.com
mac1---- -> 0x6d6163312d2d2d2d

*/

func construction() = 0x4e6f6973655f494b70736b325f32353531395f436861436861506f6c795f424c414b453273
func identifier() = 0x576972654775617264207631207a78326334204a61736f6e407a783263342e636f6d 
func mac1() = 0x6d6163312d2d2d2d

func zeros_16() = 0x00000000000000000000000000000000
func zeros_32() = 0x0000000000000000000000000000000000000000000000000000000000000000


locality Initiator : 1
locality Responder : 1

// Ephemeral Diffie-Hellman keys
name E_init<i@n> : DH @ Initiator<n>
name E_resp<i@m> : DH @ Responder<m>

// Static Diffie-Hellman keys (public keys should be preshared)
name S_init<@n> : DH @ Initiator<n>
name S_resp<@m> : DH @ Responder<m>


func honest_H1_pre<@m>() = crh(crh(construction()) ++ identifier()) ++
dhpk(get(S_resp<@m>))
func honest_H2_pre<i@n, m>() = crh(honest_H1_pre<pid m>()) ++ dhpk(get(E_init<i@n>))
func honest_H3_pre<i@n, m>(c) = 
    crh(honest_H2_pre<session i, pid n, pid m >()) ++ c
func honest_H4_pre<i@n, m>(c, ts) = 
    crh(honest_H3_pre<session i, pid n, pid m>(c)) ++ ts
func honest_H5_pre<i,j @ n, m>(c, ts) = 
    crh(honest_H4_pre<session i, pid n, pid m>(c, ts)) ++ dhpk(get(E_resp<j@m>))
func honest_H6_pre<i,j@n,m>(c, ts, tau) = crh(honest_H5_pre<session i,
session j, pid n, pid m>(c, ts)) ++ tau
func honest_H7_pre<i, j@n,m>(c, ts, tau, c') = 
    crh(honest_H6_pre<session i, session j, pid n, pid m>(c, ts, tau)) ++ c'

name channel_secret<@n,m> : nonce 

counter N_init_send<i@n> @ Initiator<n>
counter N_init_recv<i@n> @ Initiator<n>
counter N_resp_send<j@m> @ Responder<m>
counter N_resp_recv<j@m> @ Responder<m>

nametype transp_key_init_send<@n,m> = 
            st_aead (Data<adv /\ [channel_secret<@n,m>], |adv|>)
                aad x. true
                nonce N_init_send

nametype transp_key_resp_send<@n,m> = 
            st_aead (Data<adv /\ [channel_secret<@n,m>], |adv|>)
                aad x. true
                nonce N_resp_send

nametype C7<@n,m> = kdf {ikm info.
    True -> 
        strict transp_key_init_send<@n,m>
            ||
        strict transp_key_resp_send<@n,m>
}

nametype transp_key_init_send_corr = 
      st_aead (x:Data<adv>{False})
                        aad x. true
                        nonce N_init_send

nametype transp_key_resp_send_corr = 
      st_aead (x:Data<adv>{False})
                        aad x. true
                        nonce N_resp_send
    

nametype C7_corr = kdf {ikm info.
    True ->
        strict transp_key_init_send_corr
        ||
        strict transp_key_resp_send_corr
}

counter aead_counter_msg2_C7<j@m> @ Responder<m>

predicate valid_h6(h) = 
    exists n:idx,m:idx,i:idx,j:idx,c:bv,ts:bv,tau:bv.
        h == crh(honest_H6_pre<session i, session j, pid n, pid m>(c, ts, tau))
        

nametype C6_dual<@n, m> = dualkdf {salt info.
    True -> strict C7<@n,m> || public nonce || 
        strict st_aead (Data<adv> |0|)
           aad x. valid_h6[x] 
           nonce aead_counter_msg2_C7
}

name psk<@n,m> : C6_dual<@n,m> @ Initiator<n>, Responder<m>

nametype C6_corr<@n,m> = kdf {ikm info.
    True -> strict C7_corr || public nonce ||
        strict st_aead (Data<adv> |0|) // (x:(Data<adv> |0|){False})
                       aad x. (exists m2:idx. valid_h6[x])
                       nonce aead_counter_msg2_C7
}

nametype C6<@n, m> = kdf {ikm info.
    ikm == 0x -> 
        strict C7<@n,m> || public nonce || 
        strict st_aead (Data<adv> |0|)
           aad x. valid_h6[x] 
           nonce aead_counter_msg2_C7
}


nametype C5_corr<@n,m> = kdf {ikm info.
    True -> strict C6_corr<@n,m>
}


nametype C5<@n,m> = kdf {ikm info.
    True -> 
    strict C6<@n,m> 
}

func honest_c1<i@n>() = 
    gkdf<kdfkey;0>(crh(construction()), dhpk(get(E_init<i@n>)), 0x)

nametype C4_corr<@n,m> = kdf {ikm info.
    True -> strict C5_corr<@n,m>
}

nametype C4<@n,m> = kdf {ikm info.
    True -> strict C5<@n,m> 
}

locality nobody
counter useless @ nobody
nametype useless_enc = st_aead (x:Data<adv> | |group| |{False})
                        aad x. False
                        nonce useless
                        

nametype C3<@n,m> = kdf {ikm info.
    (exists j:idx. ikm == dhpk(get(E_resp<j@m>))) -> strict C4<@n,m> || strict useless_enc
    !(exists j:idx. ikm == dhpk(get(E_resp<j@m>))) -> strict C4_corr<@n,m> || strict useless_enc
}

counter aead_counter_msg1_C3<i@n> @ Initiator<n>

predicate h3_pred(h) = 
    exists n:idx,m:idx,i:idx,c:bv. 
        h == crh(honest_H3_pre<session i, pid n, pid m>(c))
        

nametype C2<@n,m> = kdf {ikm info. 
    True -> strict C3<@n,m> || strict st_aead (Data<adv> |12|)
                           aad x. h3_pred[x]
                           nonce aead_counter_msg1_C3
}

counter aead_counter_msg1_C2<i@n> @ Initiator<n>

odh L1<i@n,m> :
    E_init<i@n>, S_resp<@m> -> {salt info.
        (salt == honest_c1<session i, pid n>()) -> 
            strict C2<@n,m> || strict st_aead (dhpk(S_init<@n>))
                             aad x. true
                             nonce aead_counter_msg1_C2
}                                                            

func honest_c2<i@n,m>() =
    gkdf<kdfkey||enckey;0>(honest_c1<session i, pid n>(),
        dh_combine(dhpk(get(E_init<i@n>)), get(S_resp<@m>)), 0x)

func honest_c3<i@n,m>() = 
    gkdf<kdfkey||enckey;0>(honest_c2<session i, pid n, pid m>(), 
        dh_combine(dhpk(get(S_init<@n>)), get(S_resp<@m>)),
        0x
    )


func honest_c4<i,j@n,m>() = 
    gkdf<kdfkey||nonce||enckey;0>(honest_c3<session i, pid n, pid m>(),
        dhpk(get(E_resp<j@m>)),
        0x
    )

func honest_c5<i,j@n,m>() = 
    gkdf<kdfkey;0>(honest_c4<session i, session j, pid n, pid m>(),
        dh_combine(dhpk(get(E_init<i@n>)), get(E_resp<j@m>)),
        0x
    )

func honest_c6<i,j@n,m>() = 
    gkdf<kdfkey; 0>(honest_c5<session i, session j, pid n, pid m>(),
        dh_combine(dhpk(get(S_init<@n>)), get(E_resp<j@m>)),
        0x
    )

func honest_c7<i,j@n,m>() = 
    gkdf<kdfkey||nonce||enckey; 0>(honest_c6<session i, session j, pid n, pid m>(),
        0x,
        0x
    )


odh L2<@n,m> : 
    S_init<@n>, S_resp<@m> -> {salt info.
        (exists i:idx. salt == honest_c2<session i, pid n, pid m>())
        ->
                strict C3<@n,m> || strict st_aead (Data<adv> |12|)
                           aad x. h3_pred[x]
                           nonce aead_counter_msg1_C3
    }

odh L4<i,j@n,m> :
    E_init<i@n>, E_resp<j@m> -> {salt info.
        (salt != honest_c1<session i, pid n>())
        /\
        (salt == honest_c4<session i, session j, pid n, pid m>())
             -> strict C5<@n,m>

        (salt != honest_c1<session i, pid n>())
        /\
        (salt != honest_c4<session i, session j, pid n, pid m>())
            -> strict C5_corr<@n,m>
}

odh L5<j@n,m> :
    S_init<@n>, E_resp<j@m> -> {salt info.
        !(exists i:idx. salt == honest_c2<session i, pid n, pid m>())
        /\
        (exists i:idx. salt == honest_c5<session i, session j, pid n, pid m>())
            -> 
            strict C6<@n,m> 
}

nametype C1<@n,m> = kdf {ikm info.
    True -> strict C2<@n,m> || strict st_aead (exists n. dhpk(S_init<@n>))
                         aad x. true
                         nonce aead_counter_msg1_C2
}





////////////////////////////
// Message formats

struct msg1 {
      _msg1_tag : Const(0x01000000)
    , _msg1_sender : Data<adv> |4| // bytes??
    , _msg1_ephemeral : Data<adv> | |group| |
    , _msg1_static : Data<adv> | cipherlen(|group|) | 
    , _msg1_timestamp: Data<adv> | cipherlen(12) |
    // TODO cookie mechanism
    , _msg1_mac1: Data<adv> | |maclen| |
    , _msg1_mac2: Const(0x00000000000000000000000000000000) // hardcode |maclen|=16 zeros, for now
}

struct msg2 {
      _msg2_tag : Const(0x02000000)
    , _msg2_sender: Data<adv> |4|
    , _msg2_receiver: Data<adv> |4|
    , _msg2_ephemeral: Data<adv> | |group| |
    , _msg2_empty: Data<adv> | cipherlen(0) |
    // TODO cookie mechanism
    , _msg2_mac1: Data<adv> | |maclen| |
    , _msg2_mac2: Const(0x00000000000000000000000000000000) // hardcode |maclen|=16 zeros, for now
}


struct transp {
      _transp_tag : Const(0x04000000)
    , _transp_receiver : Data<adv> |4|
    , _transp_counter  : Data<adv> | |counter| | 
    , _transp_packet   : Data<adv> 
}


////////////////////////////
// Primitives

func padding() = 0x000000
func msg1_tag_value() = 0x01000000
func msg2_tag_value() = 0x02000000
func transp_tag_value() = 0x04000000

def get_sender_i<@n>  () @ Initiator<n> : Data<adv> |4| // TODO can we model this as a nonce?
def timestamp_i<@n>   () @ Initiator<n> : Data<adv> |12|

def get_sender_r<@m>  () @ Responder<m> : Data<adv> |4| // TODO can we model this as a nonce?
def timestamp_r<@m>   () @ Responder<m> : Data<adv> |12|


//////////////////////////
// Intermediate structures / definitions

func dh(x, y) = dh_combine(dhpk(x), y)



/////////////////////////
// Transport keys for initiator

predicate tki_secure<i,n,m>(eph) = 
    exists j:idx. 
        eph == dhpk(get(E_resp<j@m>))
        /\
         ((sec(E_resp<j@m>) /\ sec(E_init<i@n>))
          \/
          (sec(E_resp<j@m>) /\ sec(S_init<@n>))
          \/
          (sec(S_resp<@m>) /\ sec(E_init<i@n>))
          \/
          (sec(S_resp<@m>) /\ sec(S_init<@n>)))

predicate tki_corrupt<i,n,m>(eph) =
     ((corr(S_resp<@m>) \/ corr(E_init<i@n>))
          /\
      (corr(S_resp<@m>) \/ corr(S_init<@n>)))
     /\
     (forall j:idx. eph == dhpk(get(E_resp<j@m>))
        ==>
         ((corr(E_resp<j@m>) \/ corr(E_init<i@n>))
          /\
          (corr(E_resp<j@m>) \/ corr(S_init<@n>))
     ))
    

struct transp_keys_init<i,n,m> {
    tki_eph : Ghost,
    tki_c7 : Ghost,
    tki_k_init_send : if tki_secure<i,n,m>[tki_eph] then
        SecName(KDF<enckey||enckey; 0; transp_key_init_send<@n,m>>(tki_c7, 0x, 0x))
        else (x:Data<adv>{tki_corrupt<i,n,m>[tki_eph]}),
    tki_k_resp_send : if tki_secure<i,n,m>[tki_eph] then
        SecName(KDF<enckey||enckey; 1; transp_key_resp_send<@n,m>>(tki_c7, 0x, 0x))
        else (x:Data<adv>{tki_corrupt<i,n,m>[tki_eph]})
}


/////////////////////////
// Pre-Transport keys for initiator

predicate is_e_init(h) = exists n:idx,i:idx. h == dhpk(get(E_init<i@n>))
predicate is_s_init(h) = exists n:idx. h == dhpk(get(S_init<@n>))

predicate tkr_secure<j,n_eph,n_pk,m>(eph) = 
    exists i:idx. 
        eph == dhpk(get(E_init<i@n_eph>))
        /\
        (n_eph !=idx n_pk ==> sec(E_init<i@n_eph>))
        /\
         ((sec(E_resp<j@m>) /\ sec(E_init<i@n_eph>))
          \/
          (sec(E_resp<j@m>) /\ sec(S_init<@n_pk>))
          \/
          (sec(S_resp<@m>) /\ sec(E_init<i@n_eph>))
          \/
          (sec(S_resp<@m>) /\ sec(S_init<@n_pk>)))


struct transp_keys_resp<j,n_eph,n_pk,m> {
    tkr_eph : Ghost,
    tkr_c7 : Ghost,
    tkr_k_init_send : if tkr_secure<j,n_eph,n_pk,m>[tkr_eph] then
        if n_eph =idx n_pk then 
            SecName(KDF<enckey||enckey;0;transp_key_init_send<@n_eph,m>>(tkr_c7, 0x,
            0x))
        else 
            SecName(KDF<enckey||enckey;0;transp_key_init_send_corr>(tkr_c7, 0x, 0x))
        else Data<adv>, 
    tkr_k_resp_send : if tkr_secure<j,n_eph,n_pk,m>[tkr_eph] then
        if n_eph =idx n_pk then
            SecName(KDF<enckey||enckey;1;transp_key_resp_send<@n_eph,m>>(tkr_c7, 0x, 0x))
        else
            SecName(KDF<enckey||enckey;1;transp_key_resp_send_corr>(tkr_c7, 0x, 0x))
        else Data<adv> 
}
