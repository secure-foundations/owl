include "defs.owl"


def checkpk_resp<@m>(pk : Data<adv>) @ Responder<m>
    : Option (exists n. (x:shared_secret(S_init<@n>, S_resp<@m>){dhpk(get(S_init<@n>)) == pk}))

def resp_main<j@m> (dhpk_S_resp: dhpk(S_resp<@m>)) @ Responder<m>
     : Option (exists n_eph. exists n_pk. transp_keys_resp<session j, pid n_eph,
     pid n_pk, pid m>) 
     =
     set_option ":rlimit" "2000000" in 
input inp in
     parse inp as msg1(msg1_tag, msg1_sender, msg1_ephemeral, msg1_static, msg1_timestamp, msg1_mac1, msg1_mac2) in {
     guard eq(length(msg1_sender), 4) in 
     guard is_group_elem(msg1_ephemeral) in 
     let C0 = crh(construction()) in
     let H0 = crh(C0 ++ identifier()) in 
     let H1 = crh(H0 ++ dhpk_S_resp) in
     pcase 
         (is_e_init[msg1_ephemeral]) in 
         choose_idx n | exists i:idx. msg1_ephemeral == dhpk(get(E_init<i@n>)) in 
         choose_idx i | msg1_ephemeral == dhpk(get(E_init<i@n>)) in
     pcase (is_s_init[msg1_ephemeral]) when (!is_e_init[msg1_ephemeral]) in 
        choose_idx n2 | msg1_ephemeral == dhpk(get(S_init<@n2>)) in 
     let C1 = kdf<;;kdfkey;0>(C0, msg1_ephemeral, 0x) in 
     let H2 = crh(H1 ++ msg1_ephemeral) in
     let ss_msg1_ephemeral_S_resp = dh_combine(msg1_ephemeral, get(S_resp<@m>)) in
     
     corr_case  S_resp<@m> in 
     corr_case  E_init<i@n> when is_e_init[msg1_ephemeral] in 
     corr_case  S_init<@n2> when is_s_init[msg1_ephemeral] in 
     cross_dh_lemma<S_resp<@m>>(msg1_ephemeral);
     // H(a, b, c) != H(H(a, b, c), d, e)
     assume (!(exists i:idx. C1 == honest_c2<session i, pid n2, pid m>()));
     let C2 = kdf<;odh L1<i@n,m>[0]; kdfkey||enckey; 0>(C1, ss_msg1_ephemeral_S_resp, 0x) in 
     let k0 = kdf<;odh L1<i@n,m>[0]; kdfkey||enckey; 1>(C1, ss_msg1_ephemeral_S_resp, 0x) in 
     case st_aead_dec(k0, msg1_static, H2, 0x) as Option (Data<adv>) {
         | None => None()
         | Some msg1_static_dec => 
                false_elim in
                let oss = call checkpk_resp<@m>(msg1_static_dec) in
                case oss {
                    | None => None()
                    | Some res =>
                        unpack n3, ss = res in 
                        cross_dh_lemma<S_resp<@m>>(msg1_static_dec);
                        let H3 = crh(H2 ++ msg1_static) in
                        corr_case S_init<@n3> in 
                        
                        pcase (n =idx n3) in
                        let dhpk_S_init : if n =idx n3 then dhpk(S_init<@n>)
                        else dhpk(S_init<@n3>) = msg1_static_dec in
                        assume (
                        (msg1_ephemeral == dhpk(get(E_init<i@n>)) /\ n !=idx n3)
                        ==>
                        !(exists i:idx. C2 == honest_c2<session i, pid n3, pid m>()));
                        assume (!is_e_init[msg1_ephemeral] ==>
                            !(exists i:idx. C2 == honest_c2<session i, pid n, pid m>()));
                        assume (!is_e_init[msg1_ephemeral] ==>
                            !(exists i:idx. C2 == honest_c2<session i, pid n3, pid m>()));

                        let C3 = kdf<0;odh L2<@n,m>[0], odh L2<@n3,m>[0]; kdfkey || enckey; 0>(C2, ss, 0x) in 
                        let k1 = kdf<0;odh L2<@n,m>[0], odh L2<@n3,m>[0]; kdfkey || enckey; 1>(C2, ss, 0x) in 
                        case st_aead_dec(k1, msg1_timestamp, H3, 0x) as Option (Data<adv> |12|) {
                        | None => None()
                        | Some msg1_timestamp_dec =>
                            false_elim in 
                            let H4 = crh(H3 ++ msg1_timestamp) in
                            let e_resp_pk = dhpk(get(E_resp<j@m>)) in 
                            let c4 = kdf<0;;kdfkey;0>(C3, e_resp_pk, 0x) in 
                            let h5 = crh(H4 ++ e_resp_pk) in 
                            let ss = dh_combine(msg1_ephemeral, get(E_resp<j@m>)) in 
                            cross_dh_lemma<E_resp<j@m>>(msg1_ephemeral);
                            corr_case E_resp<j@m> in 
                            assume (c4 != honest_c1<session i, pid n>());
                            assume (n !=idx n3 ==>
                                c4 != honest_c4<session i, session j, pid n, pid m>()
                            );
                            assume (!exists i:idx. c4 == honest_c5<session i, session j, pid
                            n2, pid m>());
                            let c5 = kdf<0; odh L4<i,j@n,m>[0], odh L4<i,j@n,m>[1]; kdfkey; 0>(c4, ss, 0x) in 
                            assume (!(exists i:idx. c5 == honest_c2<session i, pid n, pid m>()));
                            assume (!(exists i:idx. c5 == honest_c2<session i, pid n3, pid m>()));
                            assume (n !=idx n3 ==>
                                !exists i:idx. c5 == honest_c5<session i,
                                session j, pid n3, pid m>()
                            );
                            assume (!is_e_init[msg1_ephemeral] ==>
                                !exists i:idx. c5 == honest_c5<session i,
                                    session j, pid n3, pid m>()
                            );
                            let c6 = kdf<0; odh L5<j@n,m>[0]; kdfkey;0>(c5, dh_combine(dhpk_S_init, get(E_resp<j@m>)), 0x) in 
                            let c7 = kdf<0;; kdfkey || nonce || enckey; 0>(c6, 0x, 0x) in 
                            let tau = kdf<0;; kdfkey || nonce || enckey; 1>(c6, 0x, 0x) in 
                            let k0 = kdf<0;; kdfkey || nonce || enckey; 2>(c6, 0x, 0x) in 
                            let msg2_tag = msg2_tag_value() in 
                            let msg2_sender : Data<adv> |4| = call get_sender_r<@m>() in
                            let msg2_mac1_k = crh(mac1() ++ dhpk_S_init) in
                            let msg2_receiver : Data<adv> |4| = 0x00000000 in 
                            let h6 = crh(h5 ++ tau) in
                            let msg2_empty : Data<adv> | cipherlen(0) | = st_aead_enc<aead_counter_msg2_C7<j@m>>(k0, 0x, h6) in
                            let msg2_mac1 = mac(msg2_mac1_k,
                                    msg2_tag ++ msg2_sender ++ msg2_receiver ++ e_resp_pk ++
                                    msg2_empty) in 
                            // TODO needs to be encoded
                            assume(length(msg2_mac1) == |maclen|);
                            let msg2_mac2 = zeros_16() in
                            let msg2_output: msg2 = msg2(
                                msg2_tag, msg2_sender, msg2_receiver, e_resp_pk, msg2_empty, msg2_mac1, msg2_mac2
                            ) in
                            let _ = output msg2_output /* to endpoint(Initiator<n>) */ in // (TODO: endpoint? )
                            let tk1 = kdf<0;; enckey || enckey; 0>(c7, 0x, 0x) in 
                            let tk2 = kdf<0;; enckey || enckey; 1>(c7, 0x, 0x) in 
                            /*
                            debug printTyOf(tk1);
                            debug printPathCondition;
                            */
                            Some (pack<n>(
                                pack<n3>(
                                transp_keys_resp<session j, pid n, pid n3, pid
                                m>(msg1_ephemeral, c7, tk1, tk2))))
                        otherwise => None()
                        }
                }
        otherwise => None()
     }
     } otherwise None()
