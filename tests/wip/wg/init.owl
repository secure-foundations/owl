include "defs.owl"

    
predicate is_e_resp(eph) = 
    exists m:idx,j:idx.
        eph == dhpk(get(E_resp<j@m>))

predicate is_s_resp(eph) = 
    exists m:idx.
        eph == dhpk(get(S_resp<@m>))

predicate init_safe<i,n,m>() =
    (sec(S_resp<@m>) /\ sec(E_init<i@n>)) 
    \/
    (sec(S_resp<@m>) /\ sec(S_init<@n>)) 

    
struct init_sent_state<i,n,m> {
    iss_c2 : (x:Ghost{x == honest_c2<session i, pid n, pid m>()}),
    iss_psk : PSKMode<idx n,idx m>,
    iss_static_ss : (x:Ghost{x == dh_combine(dhpk(get(S_init<@n>)),
    get(S_resp<@m>))}),
    ss_h4 : (x:Data<adv> ||crh|| {exists c:bv,ts:bv. x == crh(honest_H4_pre<session i, pid
    n,pid m>(c, ts))}),
    iss_c3 : if init_safe<i,n,m>[] then
        SecName(KDF<kdfkey||enckey;0;C3<@n,m>>(iss_c2, iss_static_ss, 0x))
        else
            (x:Data<adv>{x == honest_c3<session i, pid n, pid n, pid m>()})
}

def init_stage1<i@n,m>
    (dhpk_S_resp : dhpk(S_resp<@m>), dhpk_S_init :
    dhpk(S_init<@n>), ss_S_resp_S_init: shared_secret(S_init<@n>, S_resp<@m>), 
    psk : PSKMode<idx n,idx m>) @
    Initiator<n> : init_sent_state<session i, pid n, pid m> = 
    let C0 = crh(construction()) in
    let H0 = crh(C0 ++ identifier()) in 
    let H1 = crh(H0 ++ dhpk_S_resp) in
    let e_init = dhpk(get(E_init<i@n>)) in 
    let C1 = kdf<;;kdfkey;0>(C0, e_init, 0x) in 
    let H2 = crh(H1 ++ e_init) in
    let ss_S_resp_E_init = dh_combine(dhpk_S_resp, get(E_init<i@n>)) in
    // corr_case S_resp<@m> in
    // corr_case E_init<i@n> in
    let C2 = kdf<;odh L1<i@n,m>[0]; kdfkey||enckey; 0>(C1, ss_S_resp_E_init, 0x) in
    let k0 = kdf<;odh L1<i@n,m>[0]; kdfkey||enckey; 1>(C1, ss_S_resp_E_init, 0x) in
    let msg1_static // : Data<adv> |cipherlen(|group|)|
        = st_aead_enc<aead_counter_msg1_C2<i@n>>(k0, dhpk_S_init, H2) in 
    let H3 = crh(H2 ++ msg1_static) in
    // corr_case S_init<@n> in 
    let c3 = kdf<0;odh L2<@n,m>[0]; kdfkey || enckey; 0>(C2, ss_S_resp_S_init, 0x) in 
    let k1 = kdf<0;odh L2<@n,m>[0]; kdfkey || enckey; 1>(C2, ss_S_resp_S_init, 0x) in 
    let timestamp = call timestamp_i<@n>() in
    let msg1_timestamp = // : Data<adv> |cipherlen(12)| =
        st_aead_enc<aead_counter_msg1_C3<i@n>>(k1, timestamp, H3) in 
    let h4 = crh(H3 ++ msg1_timestamp) in

    let msg1_sender : Data<adv> |4| = call get_sender_i<@n>() in
    let msg1_tag = msg1_tag_value() in 

    let msg1_mac1_k = crh(mac1() ++ dhpk_S_resp) in 
    let msg1_mac1 = mac(msg1_mac1_k, 
        msg1_tag ++ msg1_sender ++ e_init ++ msg1_static ++ msg1_timestamp) in
    let msg1_mac2 = zeros_16() in
    let msg1_output = msg1(msg1_tag, msg1_sender, e_init, msg1_static, msg1_timestamp, msg1_mac1, msg1_mac2) in
    output msg1_output; // to endpoint(Responder<m>); // TODO: does it make sense to index the responder?
    init_sent_state<session i, pid n, pid m>(C2, psk, ss_S_resp_S_init, h4, c3)



def init_stage2<i@n,m>
    (st : init_sent_state<session i, pid n, pid m>)
    @
    Initiator<n> : Option transp_keys_init<session i, pid n, pid m> = 
    set_option ":rlimit" "7000000" in 
    parse st as init_sent_state<session i, pid n, pid m>(c2, opsk, static_ss, h4, c3)
    in 
    input i in
    parse i as msg2(msg2_tag, msg2_sender, msg2_receiver, msg2_ephemeral,
    msg2_empty_enc, msg2_mac1, msg2_mac2) in
    {
        guard andb(eq(length(msg2_sender), 4), eq(length(msg2_receiver), 4)) in
        guard is_group_elem(msg2_ephemeral) in 
        let e_init = get(E_init<i@n>) in 
        pcase is_e_resp[msg2_ephemeral] in 
            choose_idx m2 | exists j:idx. msg2_ephemeral == dhpk(get(E_resp<j@m2>)) in 
            choose_idx j | msg2_ephemeral == dhpk(get(E_resp<j@m2>)) in 
        pcase (m =idx m2) when (msg2_ephemeral == dhpk(get(E_resp<j@m2>))) in 
        pcase is_s_resp[msg2_ephemeral]
            when !is_e_resp[msg2_ephemeral]
        in 
            choose_idx m3 | msg2_ephemeral == dhpk(get(S_resp<@m3>)) in 
        // corr_case E_resp<j@m2> when (msg2_ephemeral == dhpk(get(E_resp<j@m2>)) /\ m !=idx m2) in 
        let c4 = kdf<0,1;;kdfkey;0>(c3, msg2_ephemeral, 0x) in 
        let ghost c4_ghost = gkdf<kdfkey;0>(c3, msg2_ephemeral, 0x) in 
        let h5 = crh(h4 ++ msg2_ephemeral) in                      
        let ss = dh_combine(msg2_ephemeral, e_init) in 
        cross_dh_lemma<E_init<i@n>>(msg2_ephemeral);
        // corr_case E_resp<j@m> in 
        kdf_inj_lemma(gkdf<kdfkey;0>(c3, msg2_ephemeral, 0x), honest_c1<session i, pid n>());
        kdf_inj_lemma(gkdf<kdfkey;0>(c3, msg2_ephemeral, 0x), honest_c4<session
        i, session j, pid n, pid n, pid m2>());
        kdf_inj_lemma(honest_c3<session i, pid n, pid n, pid m>(),
            honest_c3<session i, pid n, pid n, pid m2>());
        assert (m !=idx m2 ==>
            c4 != honest_c4<session i, session j, pid n, pid n, pid m2>());
        forall n_pk:idx, i':idx {
            kdf_inj_lemma(honest_c3<session i, pid n, pid n, pid m>(),
                honest_c3<session i', pid n, pid n_pk, pid m2>());
            kdf_inj_lemma(gkdf<kdfkey;0>(c3, msg2_ephemeral, 0x), honest_c4<session
                i', session j, pid n, pid n_pk, pid m2>());
            assert ((m !=idx m2 ==> c4 != honest_c4<session i', session j, pid n, pid n_pk, pid
                    m2>())
                    /\
                    (!is_e_resp[msg2_ephemeral] ==>
                        c4 != honest_c4<session i', session j, pid n, pid n_pk,
                        pid m2>()
                    ))
        };
        /*
        assert (!is_e_resp[msg2_ephemeral] ==>
            forall i:idx,j:idx.
                ss != dh_combine(dhpk(get(E_init<i@n>)), get(E_resp<j@m>))
        );
        */
        let c5 = kdf<0,1; odh L4<i,j@n,m>[0], odh
        L4<i,j@n,m2>[1]; kdfkey; 0>(c4, ss, 0x) in                                     

        let ghost c5_ghost = gkdf<kdfkey;0>(c4_ghost, ss, 0x) in 
        cross_dh_lemma<S_init<@n>>(msg2_ephemeral);

        forall i':idx {
            assert (dh_combine(dhpk(get(S_init<@n>)), get(S_resp<@m>)) != dhpk(get(E_init<i'@n>)));
            kdf_inj_lemma(c5_ghost, honest_c2<session i', pid n, pid m3>());
            kdf_inj_lemma(c5_ghost, honest_c2<session i', pid n, pid m>());
            let lem1 = assert (c5 != honest_c2<session i', pid n, pid m3>()) in
            let lem2 = assert (c5 != honest_c2<session i', pid n, pid m>())  in
            lem1 &&& lem2
        };
        assert (! exists i:idx. c5 == honest_c2<session i, pid n, pid m3>());
        assert (! exists i:idx. c5 == honest_c2<session i, pid n, pid m>());
        forall n_eph:idx,i':idx {
            kdf_inj_lemma(c5_ghost, honest_c2<session i', pid
            n_eph, pid m>());
            kdf_inj_lemma(c5_ghost, honest_c2<session i', pid
            n_eph, pid m3>());
            let lem1 = assert (c5 != honest_c2<session i', pid n_eph, pid m3>()) in
            let lem2 = assert (c5 != honest_c2<session i', pid n_eph, pid m>()) in
            lem1 &&& lem2
        };
        assert (forall n_eph:idx.
            ! exists i:idx.
                c5 == honest_c2<session i, pid n_eph, pid m3>()
        );
        assert (forall n_eph:idx.
            ! exists i:idx.
                c5 == honest_c2<session i, pid n_eph, pid m>()
        );
        forall n_eph:idx, i':idx {
            kdf_inj_lemma(c5_ghost, honest_c5<session i',
            session j, pid n_eph, pid n, pid m2>())
        };
        assert (m !=idx m2 ==>
            ! exists n_eph:idx.
                exists i:idx.
                    c5 == honest_c5<session i, session j, pid n_eph, pid n, pid
                    m2>()
        );
        // corr_case S_init<@n> in 
        let c6 = kdf<0; odh L5<j@n,m>[0]; kdfkey; 0>(c5, 
            dh_combine(msg2_ephemeral, get(S_init<@n>)), 0x
        ) in 
        let c6_ghost = gkdf<kdfkey;0>(c5_ghost, dh_combine(msg2_ephemeral, get(S_init<@n>)), 0x) in 
        forall i:idx,j:idx {
            kdf_inj_lemma(c6_ghost, honest_c6<session i, session j, pid n, pid
            n, pid m>())
        };
        assert ((m !=idx m2 \/ !is_e_resp[msg2_ephemeral]) ==>
            forall i:idx,j:idx.
                c6 != honest_c6<session i, session j, pid n, pid n, pid
                m>()
        );
        let psk : if HasPSK?(opsk) then Name(psk<@n,m>) else ty_zeros_32 = 
        case opsk {
                   | HasPSK v => v
                   | NoPSK => zeros_32()
        } in
        pcase HasPSK?(opsk) in 
        let c7 = kdf<0;0,1;kdfkey || nonce || enckey; 0>(c6, psk, 0x) in 
        let tau = kdf<0;0,1;kdfkey || nonce || enckey; 1>(c6, psk, 0x) in 
        let k0 = kdf<0;0,1;kdfkey || nonce || enckey; 2>(c6, psk, 0x) in 
        let h6 = crh(h5 ++ tau) in 
        case st_aead_dec(k0, msg2_empty_enc, h6, 0x) 
        as Option (Data<adv>|0|) {
            | None => None()
            | Some x => {
                    forall m':idx,j:idx
                        assuming (exists einit:bv,c:bv,ts:bv,tau:bv. h6 == crh(h6_pre(dhpk(get(S_resp<@m'>)), einit, c, ts, dhpk(get(E_resp<j@m'>)), tau)))
                    {
                        choose_bv einit | exists c:bv,ts:bv,tau:bv. h6 ==
                        crh(h6_pre(dhpk(get(S_resp<@m'>)), einit, c, ts, dhpk(get(E_resp<j@m'>)), tau)) in
                        choose_bv c | exists ts:bv,tau:bv. h6 == crh(h6_pre(dhpk(get(S_resp<@m'>)), einit, c, ts, dhpk(get(E_resp<j@m'>)), tau)) in
                        choose_bv ts | exists tau:bv. h6 == crh(h6_pre(dhpk(get(S_resp<@m'>)), einit, c, ts, dhpk(get(E_resp<j@m'>)), tau)) in
                        choose_bv tau | h6 == crh(h6_pre(dhpk(get(S_resp<@m'>)), einit, c, ts, dhpk(get(E_resp<j@m'>)), tau)) in
                        crh_lemma(h6, crh(h6_pre(dhpk(get(S_resp<@m'>)), einit,
                        c, ts, dhpk(get(E_resp<j@m'>)), tau)));
                        assert (h4 == crh(h4_pre(dhpk(get(S_resp<@m'>)), einit, c, ts))); 
                        choose_bv h4_c | exists h4_ts:bv. h4 == crh(honest_H4_pre<session i, pid n, pid m>(h4_c, h4_ts)) in
                        choose_bv h4_ts | h4 == crh(honest_H4_pre<session i, pid n, pid m>(h4_c, h4_ts)) in
                        crh_lemma(crh(h4_pre(dhpk(get(S_resp<@m'>)), einit, c,
                        ts)), 
                         crh(honest_H4_pre<session i, pid n, pid m>(h4_c, h4_ts))
                        );
                        assert (m' =idx m);
                        assert (m' =idx m2);
                        assert (is_e_resp[msg2_ephemeral] /\ m =idx m2)
                    };
                    assert(valid_h6[h6] ==> 
                        (is_e_resp[msg2_ephemeral] /\
                        m =idx m2));
                
                    false_elim in 
                    let k1 = kdf<0;; enckey || enckey; 0>(c7, 0x, 0x) in 
                    let k2 = kdf<0;; enckey || enckey; 1>(c7, 0x, 0x) in 
                    Some(transp_keys_init<session i, pid n, pid
                    m>(msg2_receiver, msg2_sender, HasPSK?(opsk), msg2_ephemeral, c7, k1, k2))
                }
            otherwise => None()
        }
    }
    otherwise None()



// def init_main<i@n,m> 
// (dhpk_S_resp : dhpk(S_resp<@m>), dhpk_S_init :
// dhpk(S_init<@n>), ss_S_resp_S_init: shared_secret(S_init<@n>, S_resp<@m>)) @
// Initiator<n> : Option transp_keys_init<session i, pid n, pid m> = 
//     let st = call init_stage1<i@n,m>(dhpk_S_resp, dhpk_S_init, ss_S_resp_S_init) in
//     call init_stage2<i@n,m>(st)

def init_dummy<@n>() @ Initiator<n> : Unit = ()
