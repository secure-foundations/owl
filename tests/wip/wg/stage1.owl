include "defs.owl"


def generate_msg1<i@n,m> (dhpk_S_resp : dhpk(S_resp<@m>), dhpk_S_init : dhpk(S_init<@n>), ss_S_resp_S_init: shared_secret(S_init<@n>, S_resp<@m>)) @ Initiator<n> :
  initiator_msg1_val<session i, pid n, pid m> =
    let C0 = crh(construction()) in
    let H0 = crh(C0 ++ identifier()) in 
    let H1 = crh(H0 ++ dhpk_S_resp) in
    let e_init = dhpk(get(E_init<i@n>)) in 
    let C1 = kdf<;;kdfkey;0>(C0, e_init, 0x) in 
    // let C1 = kdf<;;enckey;0>(C0, e_init, 0x) in 
    let H2 = crh(H1 ++ e_init) in
    let ss_S_resp_E_init = dh_combine(dhpk_S_resp, get(E_init<i@n>)) in
    corr_case S_resp<@m> in
    corr_case E_init<i@n> in
    let C2 = kdf<;odh L1<i@n,m>[0]; kdfkey||enckey; 0>(C1, ss_S_resp_E_init, 0x) in
    let k0 = kdf<;odh L1<i@n,m>[0]; kdfkey||enckey; 1>(C1, ss_S_resp_E_init, 0x) in
    let msg1_static // : Data<adv> |cipherlen(|group|)|
        = st_aead_enc<aead_counter_msg1_C2<i@n>>(k0, dhpk_S_init, H2) in 
    let H3 = crh(H2 ++ msg1_static) in
    // let ss_S_resp_S_init = dh_combine(dhpk_S_resp, get(S_init<@n>)) in
    corr_case S_init<@n> in 
    let C3 = kdf<0;odh L2<@n,m>[0]; kdfkey || enckey; 0>(C2, ss_S_resp_S_init, 0x) in 
    let k1 = kdf<0;odh L2<@n,m>[0]; kdfkey || enckey; 1>(C2, ss_S_resp_S_init, 0x) in 
    let timestamp = call timestamp_i<@n>() in
    let msg1_timestamp = // : Data<adv> |cipherlen(12)| =
        st_aead_enc<aead_counter_msg1_C3<i@n>>(k1, timestamp, H3) in 
    let H4 : Data<adv> = crh(H3 ++ msg1_timestamp) in

    let msg1_sender : Data<adv> |4| = call get_sender_i<@n>() in
    let msg1_tag = msg1_tag_value() in 

    // let msg1_mac1_k = hash<msg1_mac1_key<@m>>(mac1(), dhpk_S_resp) in 
    let msg1_mac1_k = crh(mac1() ++ dhpk_S_resp) in 
    let msg1_mac1 = mac(msg1_mac1_k, 
        msg1_tag ++ msg1_sender ++ e_init ++ msg1_static ++ msg1_timestamp) in
    let msg1_mac2 = zeros_16() in
    let msg1_output /* : msg1 */ = msg1(msg1_tag, msg1_sender, e_init, msg1_static, msg1_timestamp, msg1_mac1, msg1_mac2) in
    // let msg1_output = msg1(msg1_payload_value) in
    let _ = output msg1_output to endpoint(Responder<m>) in // TODO: does it make sense to index the responder?
    let retval = initiator_msg1_val<session i, pid n, pid m>(C2, C3, H4) in
    retval


def checkpk_resp<@m>(pk : Data<adv>) @ Responder<m>
    : Option (exists n. (x:shared_secret(S_init<@n>, S_resp<@m>){dhpk(get(S_init<@n>)) == pk}))



def receive_msg1<@m> (dhpk_S_resp: dhpk(S_resp<@m>)) @ Responder<m>
     : Option (exists n. exists i. responder_msg1_val<idx i, idx n, idx m>) 
     =
     set_option ":rlimit" "2000000" in 
     input inp in
     parse inp as msg1(msg1_tag, msg1_sender, msg1_ephemeral, msg1_static, msg1_timestamp, msg1_mac1, msg1_mac2) in {
     guard eq(length(msg1_sender), 4) in 
     guard is_group_elem(msg1_ephemeral) in 
     let C0 = crh(construction()) in
     let H0 = crh(C0 ++ identifier()) in 
     let H1 = crh(H0 ++ dhpk_S_resp) in
     pcase (is_e_init[msg1_ephemeral]) in 
         choose_idx n | exists i:idx. msg1_ephemeral == dhpk(get(E_init<i@n>)) in 
         choose_idx i | msg1_ephemeral == dhpk(get(E_init<i@n>)) in
     pcase (is_s_init[msg1_ephemeral]) when (!is_e_init[msg1_ephemeral]) in 
        choose_idx n2 | msg1_ephemeral == dhpk(get(S_init<@n2>)) in 
     let C1 = kdf<;;kdfkey;0>(C0, msg1_ephemeral, 0x) in 
     let H2 = crh(H1 ++ msg1_ephemeral) in
     let ss_msg1_ephemeral_S_resp = dh_combine(msg1_ephemeral, get(S_resp<@m>)) in
     
     corr_case S_resp<@m> in 
     corr_case E_init<i@n> when is_e_init[msg1_ephemeral] in 
     corr_case S_init<@n2> when is_s_init[msg1_ephemeral] in 
     cross_dh_lemma<S_resp<@m>>(msg1_ephemeral);
     // H(a, b, c) != H(H(a, b, c), d, e)
     assume (
        ! exists i:idx. C1 == honest_c2<session i, pid n2, pid m>());
     let C2 = kdf<;odh L1<i@n,m>[0]; kdfkey||enckey; 0>(C1, ss_msg1_ephemeral_S_resp, 0x) in 
     let k0 = kdf<;odh L1<i@n,m>[0]; kdfkey||enckey; 1>(C1, ss_msg1_ephemeral_S_resp, 0x) in 
     case st_aead_dec(k0, msg1_static, H2, 0x) as Option (dhpk(S_init<@n>)) {
         | None => None()
         | Some msg1_static_dec => 
                false_elim in
                let oss = call checkpk_resp<@m>(msg1_static_dec) in
                case oss {
                    | None => None()
                    | Some res =>
                        unpack n3, ss = res in 
                        let dhpk_S_init : dhpk(S_init<@n3>) = msg1_static_dec in
                        cross_dh_lemma<S_resp<@m>>(dhpk_S_init);
                        assert (msg1_static_dec == dhpk(get(S_init<@n>)) ==> n =idx n3);
                        assume (
                            forall i:idx.
                                msg1_ephemeral != dhpk(get(E_init<i@n3>)) ==> 
                                gkdf<kdfkey||enckey; 0>(
                                    gkdf<kdfkey;0>(crh(construction()), msg1_ephemeral, 0x),
                                    dh_combine(msg1_ephemeral, get(S_resp<@m>)),
                                    0x)
                                !=
                                gkdf<kdfkey||enckey; 0>(
                                    gkdf<kdfkey;0>(crh(construction()), dhpk(get(E_init<i@n3>)), 0x),
                                    dh_combine(dhpk(get(E_init<i@n3>)), get(S_resp<@m>)),
                                    0x)
                        );
                        let H3 = crh(H2 ++ msg1_static) in
                        corr_case S_init<@n3> in 
                        
                        assume (
                            n !=idx n3 ==> 
                            forall i:idx, j:idx.
                                gkdf<kdfkey||enckey; 0>(
                                    gkdf<kdfkey;0>(crh(construction()), dhpk(get(E_init<i@n>)), 0x),
                                    dh_combine(dhpk(get(E_init<i@n>)), get(S_resp<@m>)),
                                    0x)
                                !=
                                gkdf<kdfkey||enckey; 0>(
                                    gkdf<kdfkey;0>(crh(construction()), dhpk(get(E_init<j@n3>)), 0x),
                                    dh_combine(dhpk(get(E_init<j@n3>)), get(S_resp<@m>)),
                                    0x)
                        );
                        pcase (n !=idx n3) in


                        assert (n !=idx n3 ==>
                            !(exists i:idx. C2 == honest_c2<session i, pid n3, pid m>()));
                        assert (n !=idx n3 ==>
                            ss != dh_combine(dhpk(get(S_init<@n>)),
                            get(S_resp<@m>)));
                        let C3 = kdf<0;odh L2<@n,m>[0], odh L2<@n3,m>[0]; kdfkey || enckey; 0>(C2, ss, 0x) in 
                        assume (C3 == honest_c3<session i, pid n, pid m>() ==>
                            C2 == honest_c2<session i, pid n, pid m>() /\
                            ss == dh_combine(dhpk(get(S_init<@n>)),
                            get(S_resp<@m>))
                        );
                        let k1 = kdf<0;odh L2<@n,m>[0], odh L2<@n3,m>[0]; kdfkey || enckey; 1>(C2, ss, 0x) in 
                        case st_aead_dec(k1, msg1_timestamp, H3, 0x) as Option (Data<adv> |12|) {
                        | None => None()
                        | Some msg1_timestamp_dec =>
                            false_elim in 
                            let H4 = crh(H3 ++ msg1_timestamp) in
                            Some(pack<n>(pack<i>(responder_msg1_val<idx i, idx
                            n, idx m>(msg1_ephemeral, msg1_static_dec, C2, C3, H4))))
                        otherwise => None()
                        }
                }
        otherwise => None()
     }
     } otherwise None()

