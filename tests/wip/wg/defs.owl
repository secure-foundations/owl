
/*

type := 0x1 (1 byte) 
reserved := 0^3 (3 bytes)
sender := I_i (4 bytes)
ephemeral (32 bytes)
static (32 bytes)
timestamp (12 bytes)
mac1 (16 bytes) 
mac2 (16 bytes)

CONSTANTS:
construction -> Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s
identifier -> WireGuard v1 zx2c4 Jason@zx2c4.com
mac1---- -> 0x6d6163312d2d2d2d

*/

func construction() = 0x4e6f6973655f494b70736b325f32353531395f436861436861506f6c795f424c414b453273
func identifier() = 0x576972654775617264207631207a78326334204a61736f6e407a783263342e636f6d 
func mac1() = 0x6d6163312d2d2d2d

func zeros_16() = 0x00000000000000000000000000000000
func zeros_32() = 0x0000000000000000000000000000000000000000000000000000000000000000


locality Initiator : 1
locality Responder : 1

// Ephemeral Diffie-Hellman keys
name E_init<i@n> : DH @ Initiator<n>
name E_resp<i@m> : DH @ Responder<m>

// Static Diffie-Hellman keys (public keys should be preshared)
name S_init<@n> : DH @ Initiator<n>
name S_resp<@m> : DH @ Responder<m>


func h1_pre(s_resp) = crh(crh(construction()) ++ identifier()) ++ s_resp
func h2_pre(s_resp, e_init) = crh(h1_pre(s_resp)) ++ e_init
func h3_pre(s_resp, e_init, c) = crh(h2_pre(s_resp, e_init)) ++ c
func h4_pre(s_resp, e_init, c, ts) = crh(h3_pre(s_resp, e_init, c)) ++ ts
func h5_pre(s_resp, e_init, c, ts, e_resp) = crh(h4_pre(s_resp, e_init, c, ts)) ++ e_resp
func h6_pre(s_resp, e_init, c, ts, e_resp, tau) = crh(h5_pre(s_resp, e_init, c, ts, e_resp)) ++ tau

func honest_H4_pre<i@n,m>(c, ts) = h4_pre(dhpk(get(S_resp<@m>)), dhpk(get(E_init<i@n>)), c, ts)

name channel_secret_init_send<@n,m> : nonce 
name channel_secret_resp_send<@n,m> : nonce 

corr<i,n,m> [S_init<@n>] /\ [E_init<i@n>] ==> [channel_secret_init_send<@n,m>]
corr<n,m> [S_resp<@m>] ==> [channel_secret_init_send<@n,m>]

corr<j,n,m> [S_resp<@m>] /\ [E_resp<j@m>] ==> [channel_secret_resp_send<@n,m>]
corr<n,m> [S_init<@n>] ==> [channel_secret_resp_send<@n,m>]


counter N_init_send<i@n> @ Initiator<n>
counter N_init_recv<i@n> @ Initiator<n>
counter N_resp_send<j@m> @ Responder<m>
counter N_resp_recv<j@m> @ Responder<m>

nametype transp_key_init_send<@n,m> = 
            st_aead (Data<adv /\ [channel_secret_init_send<@n,m>], |adv|>)
                aad x. true
                nonce N_init_send

nametype transp_key_resp_send<@n,m> = 
            st_aead (Data<adv /\ [channel_secret_resp_send<@n,m>], |adv|>)
                aad x. true
                nonce N_resp_send

nametype C7<@n,m> = kdf {ikm info.
    True -> 
        strict transp_key_init_send<@n,m>
            ||
        strict transp_key_resp_send<@n,m>
}

nametype transp_key_init_send_corr = 
      st_aead (x:Data<adv>{False})
                        aad x. true
                        nonce N_init_send

nametype transp_key_resp_send_corr = 
      st_aead (x:Data<adv>{False})
                        aad x. true
                        nonce N_resp_send
    

nametype C7_corr = kdf {ikm info.
    True ->
        strict transp_key_init_send_corr
        ||
        strict transp_key_resp_send_corr
}

counter aead_counter_msg2_C7<j@m> @ Responder<m>

predicate valid_h6(h) = 
    exists m:idx,j:idx,einit:bv,c:bv,ts:bv,tau:bv.
        h == crh(h6_pre(dhpk(get(S_resp<@m>)), einit, c, ts, dhpk(get(E_resp<j@m>)), tau))

func honest_c1<i@n_eph>() = 
    gkdf<kdfkey;0>(crh(construction()), dhpk(get(E_init<i@n_eph>)), 0x)
        
func honest_c2<i@n_eph,m>() =
    gkdf<kdfkey||enckey;0>(honest_c1<session i, pid n_eph>(),
        dh_combine(dhpk(get(E_init<i@n_eph>)), get(S_resp<@m>)), 0x)

func honest_c3<i@n_eph, n_pk,m>() = 
    gkdf<kdfkey||enckey;0>(honest_c2<session i, pid n_eph, pid m>(), 
        dh_combine(dhpk(get(S_init<@n_pk>)), get(S_resp<@m>)),
        0x
    )


func honest_c4<i,j@n_eph,n_pk,m>() = 
    gkdf<kdfkey||nonce||enckey;0>(honest_c3<session i, pid n_eph, pid n_pk, pid m>(),
        dhpk(get(E_resp<j@m>)),
        0x
    )

func honest_c5<i,j@n_eph,n_pk,m>() = 
    gkdf<kdfkey;0>(honest_c4<session i, session j, pid n_eph, pid n_pk, pid m>(),
        dh_combine(dhpk(get(E_init<i@n_eph>)), get(E_resp<j@m>)),
        0x
    )

func honest_c6<i,j@n_eph,n_pk,m>() = 
    gkdf<kdfkey; 0>(honest_c5<session i, session j, pid n_eph, pid n_pk, pid m>(),
        dh_combine(dhpk(get(S_init<@n_pk>)), get(E_resp<j@m>)),
        0x
    )

func honest_c7<i,j@n_eph,n_pk,m>() = 
    gkdf<kdfkey||nonce||enckey; 0>(honest_c6<session i, session j, pid n_eph,
    pid n_pk, pid m>(),
        0x,
        0x
    )


nametype C6_dual<@n, m> = dualkdf {salt info.
    (exists i:idx,j:idx. salt == honest_c6<session i, session j, pid n, pid n, pid m>()) -> strict C7<@n,m> || public nonce || 
        strict st_aead (Data<adv> |0|)
           aad x. valid_h6[x] 
           nonce aead_counter_msg2_C7,
    (forall i:idx,j:idx. salt != honest_c6<session i, session j, pid n, pid n, pid m>()) -> strict C7_corr || public nonce || 
        strict st_aead (Data<adv> |0|)
           aad x. valid_h6[x]
           nonce aead_counter_msg2_C7
}

name psk<@n,m> : C6_dual<@n,m> // @ Initiator<n>, Responder<m>

enum PSKMode<n,m> {
    | HasPSK Name(psk<@n,m>)
    | NoPSK
}

nametype C6_corr = kdf {ikm info.
    True -> strict C7_corr || public nonce ||
        strict st_aead (Data<adv> |0|) // (x:(Data<adv> |0|){False})
                       aad x. valid_h6[x]
                       nonce aead_counter_msg2_C7
}

nametype C6<@n, m> = kdf {ikm info.
    (ikm == 0x \/ ikm == get(psk<@n,m>)) -> 
        strict C7<@n,m> || public nonce || 
        strict st_aead (Data<adv> |0|)
           aad x. valid_h6[x] 
           nonce aead_counter_msg2_C7
}


nametype C5_corr = kdf {ikm info.
    True -> strict C6_corr
}


nametype C5<@n,m> = kdf {ikm info.
    True -> 
    strict C6<@n,m> 
}



nametype C4_corr = kdf {ikm info.
    True -> strict C5_corr
}

nametype C4<@n,m> = kdf {ikm info.
    (exists i:idx,j:idx. ikm == dh_combine(dhpk(get(E_init<i@n>)), get(E_resp<j@m>))) -> strict C5<@n,m>, 
    (forall i:idx,j:idx. ikm != dh_combine(dhpk(get(E_init<i@n>)), get(E_resp<j@m>))) -> strict C5_corr
}

locality nobody
counter useless @ nobody
nametype useless_enc = st_aead (x:Data<adv> | |group| |{False})
                        aad x. False
                        nonce useless
                        

nametype C3<@n,m> = kdf {ikm info.
    (exists j:idx. ikm == dhpk(get(E_resp<j@m>))) -> strict C4<@n,m> || strict useless_enc, 
    (forall j:idx. ikm != dhpk(get(E_resp<j@m>))) -> strict C4_corr || strict useless_enc
    // !(exists j:idx. ikm == dhpk(get(E_resp<j@m>))) -> strict C4_corr<@n,m> || strict useless_enc
}

nametype C3_corr = kdf {ikm info.
    True -> strict C4_corr || strict useless_enc
}

counter aead_counter_msg1_C3<i@n> @ Initiator<n>

predicate h3_pred(h) = 
    exists n:idx,m:idx,i:idx,c:bv. 
        h == crh(h3_pre(dhpk(get(S_resp<@m>)), dhpk(get(E_init<i@n>)), c))
        

nametype C2<@n,m> = kdf {ikm info. 
    True -> strict C3<@n,m> || strict st_aead (Data<adv> |12|)
                           aad x. h3_pred[x]
                           nonce aead_counter_msg1_C3
}

counter aead_counter_msg1_C2<i@n> @ Initiator<n>

odh L1<i@n,m> :
    E_init<i@n>, S_resp<@m> -> {salt info.
        salt == honest_c1<session i, pid n>() -> 
            strict C2<@n,m> || strict st_aead (dhpk(S_init<@n>))
                             aad x. true
                             nonce aead_counter_msg1_C2
}                                                            


odh L2<@n,m> : 
    S_init<@n>, S_resp<@m> -> {salt info.
        (exists i:idx. salt == honest_c2<session i, pid n, pid m>()) -> 
                strict C3<@n,m> || strict st_aead (Data<adv> |12|)
                           aad x. h3_pred[x]
                           nonce aead_counter_msg1_C3,
        <n_eph>
        n_eph !=idx n /\ 
        (!exists i:idx. salt == honest_c2<session i, pid n, pid m>())
        /\
        (exists i:idx.
            salt == honest_c2<session i, pid n_eph, pid m>())
            ->
                strict C3_corr || strict st_aead (Data<adv> |12|)
                                   aad x. h3_pred[x]
                                   nonce aead_counter_msg1_C3
        
    }

odh L4<i,j@n,m> :
    E_init<i@n>, E_resp<j@m> -> {salt info.
        salt == honest_c4<session i, session j, pid n, pid n, pid m>()
             -> strict C5<@n,m>,

        salt != honest_c4<session i, session j, pid n, pid n, pid m>()
            -> strict C5_corr
}

odh L5<j@n,m> :
    S_init<@n>, E_resp<j@m> -> {salt info.
        (exists i:idx. salt == honest_c5<session i, session j, pid n, pid n, pid m>())
            -> 
            strict C6<@n,m>,

        <n_eph> 
        n_eph !=idx n /\
        (! exists i:idx. salt == honest_c5<session i, session j, pid n, pid n, pid m>()) /\
        (exists i:idx.
            salt == honest_c5<session i, session j, pid n_eph,
            pid n, pid m>()
        ) ->
            strict C6_corr

}

nametype C1<@n,m> = kdf {ikm info.
    True -> strict C2<@n,m> || strict st_aead (exists n. dhpk(S_init<@n>))
                         aad x. true
                         nonce aead_counter_msg1_C2
}





////////////////////////////
// Message formats

struct msg1 {
      _msg1_tag : Const(0x01000000)
    , _msg1_sender : Data<adv> |4| // bytes??
    , _msg1_ephemeral : Data<adv> | |group| |
    , _msg1_static : Data<adv> | cipherlen(|group|) | 
    , _msg1_timestamp: Data<adv> | cipherlen(12) |
    // TODO cookie mechanism
    , _msg1_mac1: Data<adv> | |maclen| |
    , _msg1_mac2: Const(0x00000000000000000000000000000000) // hardcode |maclen|=16 zeros, for now
}

struct msg2 {
      _msg2_tag : Const(0x02000000)
    , _msg2_sender: Data<adv> |4|
    , _msg2_receiver: Data<adv> |4|
    , _msg2_ephemeral: Data<adv> | |group| |
    , _msg2_empty: Data<adv> | cipherlen(0) |
    // TODO cookie mechanism
    , _msg2_mac1: Data<adv> | |maclen| |
    , _msg2_mac2: Const(0x00000000000000000000000000000000) // hardcode |maclen|=16 zeros, for now
}


struct transp {
      _transp_tag : Const(0x04000000)
    , _transp_receiver : Data<adv> |4|
    , _transp_counter  : Data<adv> | |counter| | 
    , _transp_packet   : Data<adv> 
}


////////////////////////////
// Primitives

func padding() = 0x000000
func msg1_tag_value() = 0x01000000
func msg2_tag_value() = 0x02000000
func transp_tag_value() = 0x04000000

def get_sender_i<@n>  () @ Initiator<n> : Data<adv> |4| // TODO can we model this as a nonce?
def timestamp_i<@n>   () @ Initiator<n> : Data<adv> |12|

def get_sender_r<@m>  () @ Responder<m> : Data<adv> |4| // TODO can we model this as a nonce?
def timestamp_r<@m>   () @ Responder<m> : Data<adv> |12|


//////////////////////////
// Intermediate structures / definitions

func dh(x, y) = dh_combine(dhpk(x), y)



/////////////////////////
// Transport keys for initiator

predicate init_clean<i,n,m>(haspsk, eph) = 
    ((haspsk == true) /\ sec(psk<@n,m>))
    \/
    (
    (sec(S_init<@n>) \/ sec(E_init<i@n>))
    /\
    (
    sec(S_resp<@m>)
    \/
    (exists j:idx. eph == dhpk(get(E_resp<j@m>)) /\
     sec(E_resp<j@m>)
    )))

struct transp_keys_init<i,n,m> {
    tki_msg2_receiver : Data<adv> |4|,
    tki_msg2_sender : Data<adv> |4|,
    tki_has_psk : Bool<adv>,
    tki_eph : Ghost,
    tki_c7 : Ghost,
    tki_k_init_send : if init_clean<i,n,m>[tki_has_psk, tki_eph] then
        SecName(KDF<enckey||enckey; 0; transp_key_init_send<@n,m>>(tki_c7, 0x, 0x))
        else Data<adv>,
    tki_k_resp_send : if init_clean<i,n,m>[tki_has_psk, tki_eph] then
        SecName(KDF<enckey||enckey; 1; transp_key_resp_send<@n,m>>(tki_c7, 0x, 0x))
        else Data<adv>
}


/////////////////////////
// (Pre-)Transport keys for initiator

predicate resp_clean<j,n_pk,n_eph,m>(haspsk, eph) = 
    (haspsk == true /\ sec(psk<@n_pk, m>))
    \/
    (
    (exists i:idx. eph == dhpk(get(E_init<i@n_eph>)))
    /\
    ((sec(S_resp<@m>) /\ sec(S_init<@n_pk>))
     \/
     (sec(E_resp<j@m>) /\ sec(S_init<@n_pk>))
     \/
     (exists i:idx. eph == dhpk(get(E_init<i@n_eph>)) /\
         ((sec(S_resp<@m>) /\ sec(E_init<i@n_eph>))
          \/
          (sec(E_resp<j@m>) /\ sec(E_init<i@n_eph>))))))

struct transp_keys_resp<j,n_pk,n_eph,m> {
    tkr_msg2_receiver : Data<adv> |4|,
    tkr_msg2_sender : Data<adv> |4|,
    tkr_has_psk : Bool<adv>,
    tkr_eph : Ghost,
    tkr_c7 : Ghost,
    tkr_recvd : (x:Bool<adv>{(x == true /\ resp_clean<j,n_pk,n_eph,m>[tkr_has_psk, tkr_eph]) ==> n_pk =idx n_eph}),
    tkr_k_init_send : if resp_clean<j,n_pk,n_eph,m>[tkr_has_psk, tkr_eph] then
        if n_pk =idx n_eph then 
              SecName(KDF<enckey||enckey;0;transp_key_init_send<@n_eph,m>>(tkr_c7, 0x, 0x))
        else
            SecName(KDF<enckey||enckey;0;transp_key_init_send_corr>(tkr_c7, 0x, 0x))
        else
        Data<adv>, 
    tkr_k_resp_send : if resp_clean<j,n_pk,n_eph,m>[tkr_has_psk, tkr_eph] then
        if n_pk =idx n_eph then 
            SecName(KDF<enckey||enckey;1;transp_key_resp_send<@n_eph,m>>(tkr_c7,
            0x, 0x))
        else
            SecName(KDF<enckey||enckey;1;transp_key_resp_send_corr>(tkr_c7, 0x, 0x))
        else Data<adv> 
}
