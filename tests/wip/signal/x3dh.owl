locality alice
locality bob

// long-term keys, assumed to be verified out of band
name d : nonce @ alice
counter N_c @ alice
counter N_c_bob @ bob

name long_skA : DH @ alice
name long_skB : DH @ bob
odh L : long_skA, long_skB -> 
    {salt info.
        True -> enckey Name(d)
    }

name ae1 : DH @ alice
name ae2 : DH @ alice

name bo : DH @ bob
name bs : DH @ bob

name be2 : DH @ bob

name ma1 : nonce @ alice
name ma2 : nonce @ alice

name long_sskA : sigkey(dhpk(ae1)) @ alice
name long_sskB : sigkey(dhpk(bs)) @ bob


struct bob_prekey_msg {
  _b1: dhpk(bo),
  _b2: dhpk(bs), 
  _b3: dhpk(long_skB),
  _b4: Data<adv> ||signature||
}

struct alice_prekey_msg {
  _a1: dhpk(ae1),
  _a2: dhpk(long_skA),
  _a3: Data<adv>
}

predicate alice_main_clean(b1, b3) =
  // is_group_elem(b1) /\
  // is_group_elem(b3) /\
  (b3 == dhpk(get(long_skB))) /\
  (b1 == dhpk(get(bo)))

func alice_honest_dh() = 
    dh_combine(dhpk(get(bs)), get(long_skA))
    ++ dh_combine(dhpk(get(long_skB)), get(ae1))
    ++ dh_combine(dhpk(get(bs)), get(ae1))
    ++ dh_combine(dhpk(get(bo)), get(ae1))

func alice_honest_amaster() =
  gkdf<kdfkey;0>(0x, alice_honest_dh(), 0x)


// check whether dualkdf or kdf
nametype Amaster = dualkdf { salt info.
  True -> strict nonce /* TODO: this should be recursive KDF ratchet */ 
            ||
          strict st_aead Name(ma1)
            aad x. (x == dhpk(get(ae1)) ++ dhpk(get(long_skA)))
            nonce N_c
}

// Corrupt version of Amaster
// check whether dualkdf or kdf
nametype Amaster_corr = dualkdf { salt info.
  True -> nonce /* TODO: this should be recursive KDF ratchet */ 
            ||
          st_aead (x:Data<adv> ||nonce|| {False}) // corrupt version of Name(ma1)
            aad x. true
            nonce N_c
}


// these need to be stacked instances of KDF names. wireguard -> nametypes
odh L1 : bs, long_skA -> 
  {salt info.
      True -> strict Amaster
      // alice_main_clean(..., ...) -> strict Amaster,
      // !alice_main_clean(..., ...) -> strict Amaster_corr
      // (!(sec(long_skA) /\ sec(bs))) -> strict Amaster_corr
  }

odh L2 : long_skB, ae1 -> 
  {salt info.
      True -> strict Amaster
      // alice_main_clean(..., ...) -> strict Amaster,
      // !alice_main_clean(..., ...) -> strict Amaster_corr
      // sec(long_skA) /\ sec(long_skB) /\ sec(ae1) /\ sec(bs) /\ sec(bo) -> strict Amaster,
      // (!(sec(long_skA) /\ sec(long_skB) /\ sec(ae1) /\ sec(bs) /\ sec(bo))) -> strict Amaster_corr
  }

odh L3 : bs, ae1 -> 
  {salt info.
      True -> strict Amaster
      // sec(long_skA) /\ sec(long_skB) /\ sec(ae1) /\ sec(bs) /\ sec(bo) -> strict Amaster,
      // (!(sec(long_skA) /\ sec(long_skB) /\ sec(ae1) /\ sec(bs) /\ sec(bo))) -> strict Amaster_corr
  }

odh L4 : bo, ae1 -> 
  {salt info.
      True -> strict Amaster
      // sec(long_skA) /\ sec(long_skB) /\ sec(ae1) /\ sec(bs) /\ sec(bo) -> strict Amaster,
      // (!(sec(long_skA) /\ sec(long_skB) /\ sec(ae1) /\ sec(bs) /\ sec(bo))) -> strict Amaster_corr
  }

/*

TODO: for L2 and L4, figure out how to assign types to the case where
b1 and b3 are not actually dhpk(long_skB) and dhpk(bo) respectively, and
how to case on whether these are true in the ODH decl/in the proof of alice_main.

*/



////// Corruption scenarios
corr [long_sskA] ==> [long_skA]
corr [long_sskB] ==> [long_skB] /\ [bs] /\ [long_skA] /\ [ma1]
corr [long_skA] ==> [ma1]
corr [bs] ==> [ma1]

// Alice initiates conversation with Bob by looking up Bob's prekey message
// from the signal server and creating the first alice message
def alice_main () @ alice
: Option Unit =

  let long_vkB = get_vk(long_sskB) in
  let gae1 = dhpk(get(ae1)) in

  input i1, _ in // Bob's prekey message implicitly from Signal server
  pcase (sec(long_sskB)) in

  parse i1 as bob_prekey_msg(b1, b2, b3, b4) in
  guard is_group_elem(b1) in 
  guard is_group_elem(b2) in 
  guard is_group_elem(b3) in 
  case vrfy(long_vkB, b2, b4) {
    | None => None()
    | Some gbs =>
      // b1 -> gbo, b2 -> gbs, b3 -> long_pkB, b4 -> gbssig
      pcase (sec(ae1)) in
      pcase (sec(bs)) in
      pcase (sec(bo)) in
      pcase (sec(long_skA)) in
      pcase (sec(long_skB)) in
      pcase (dh_combine(b3, get(ae1)) == dh_combine(dhpk(get(long_skB)), get(ae1))) in
      pcase (dh_combine(b1, get(ae1)) == dh_combine(dhpk(get(bo)), get(ae1))) in
      cross_dh_lemma<long_skA>(gbs);
      cross_dh_lemma<ae1>(b3);
      cross_dh_lemma<ae1>(gbs);
      cross_dh_lemma<ae1>(b1);
      false_elim in
      let s1 = dh_combine(gbs, get(long_skA)) in 
      let s2 = dh_combine(b3, get(ae1)) in
      let s3 = dh_combine(gbs, get(ae1)) in
      let s4 = dh_combine(b1, get(ae1)) in
      let dh = s1 ++ s2 ++ s3 ++ s4 in 
      debug "====";
      debug printTyOf(s1);
      debug printTyOf(s2);
      debug printTyOf(s3);
      debug printTyOf(s4);
      debug "====";

      let amaster = kdf<;odh L1[0], odh L2[0], odh L3[0], odh L4[0];kdfkey;0>(0x, dh, 0x) in 
      // debug printTyContext;
      
      let ra1 = kdf<;0;nonce || enckey;0>(0x, amaster, 0x) in 
      let ca1 = kdf<;0;nonce || enckey;1>(0x, amaster, 0x) in 
      pcase corr(ma1) in
      false_elim in
      let x1 = st_aead_enc<N_c>(ca1, get(ma1), gae1 ++ dhpk(get(long_skA))) in
      let a1 = alice_prekey_msg(gae1, dhpk(get(long_skA)), x1) in
      let _ = output a1 to endpoint(bob) in
      debug "---> successfully typechecked alice_main in this scenario";
      Some(())

  }
  otherwise None()

// def bob_main () @ bob
// : Unit = 
//   let long_vkA = get_vk(long_sskA) in
//   let long_pkB = dhpk(get(long_skB)) in

//   let gbo = dhpk(get(bo)) in
//   let gbs = dhpk(get(bs)) in 
//   let gbssig = sign(get(long_sskB), gbs) in
//   let b1 = bob_prekey_msg(gbo, gbs, gbssig, long_pkB) in
//   let _ = output b1 to endpoint(alice) in

//   input i2, _ in
//   parse i2 as alice_prekey_msg(a1, a2, a3) in {
//     // a1 -> gae1, a2 -> long_pkA, a3 -> x1
//     let s1 = dh_combine(a2, get(bs)) in 
//     let s2 = dh_combine(a1, get(long_skB)) in 
//     let s3 = dh_combine(a1, get(bs)) in 
//     let s4 = dh_combine(a1, get(bo)) in 
//     let dh = s1 ++ s2 ++ s3 ++ s4 in 

//     let bmaster = kdf<;odh L1[0], odh L2[0], odh L3[0], odh L4[0];enckey;0>(0x, dh, 0x) in 

//     let rb1 = kdf<;0;enckey || enckey;0>(0x, bmaster, 0x) in 
//     let cb1 = kdf<;0;enckey || enckey;1>(0x, bmaster, 0x) in 

//     let n_c = get_counter N_c_bob in
//     case st_aead_dec(cb1, a3, a1 ++ a2, n_c) {
//       | None => ()
//       | Some ma1 => ()
//     }
//   }
//   otherwise ()