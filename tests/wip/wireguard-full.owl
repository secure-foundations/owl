set_option ":rlimit" "2000000"
/*

type := 0x1 (1 byte) 
reserved := 0^3 (3 bytes)
sender := I_i (4 bytes)
ephemeral (32 bytes)
static (32 bytes)
timestamp (12 bytes)
mac1 (16 bytes) 
mac2 (16 bytes)

CONSTANTS:
construction -> Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s
identifier -> WireGuard v1 zx2c4 Jason@zx2c4.com
mac1---- -> 0x6d6163312d2d2d2d

*/

func construction() = 0x4e6f6973655f494b70736b325f32353531395f436861436861506f6c795f424c414b453273
func identifier() = 0x576972654775617264207631207a78326334204a61736f6e407a783263342e636f6d 
func mac1() = 0x6d6163312d2d2d2d

func zeros_16() = 0x00000000000000000000000000000000
func zeros_32() = 0x0000000000000000000000000000000000000000000000000000000000000000


locality Initiator : 1
locality Responder : 1

// Ephemeral Diffie-Hellman keys
name E_init<i@n> : DH @ Initiator<n>
name E_resp<i@m> : DH @ Responder<m>

// Static Diffie-Hellman keys (public keys should be preshared)
name S_init<@n> : DH @ Initiator<n>
name S_resp<@m> : DH @ Responder<m>


func honest_H1_pre<@m>() = crh(crh(construction()) ++ identifier()) ++
dhpk(get(S_resp<@m>))
func honest_H2_pre<i@n, m>() = crh(honest_H1_pre<pid m>()) ++ dhpk(get(E_init<i@n>))
func honest_H3_pre<i@n, m>(c) = 
    crh(honest_H2_pre<session i, pid n, pid m >()) ++ c
func honest_H4_pre<i@n, m>(c, ts) = 
    crh(honest_H3_pre<session i, pid n, pid m>(c)) ++ ts
func honest_H5_pre<i,j @ n, m>(c, ts) = 
    crh(honest_H4_pre<session i, pid n, pid m>(c, ts)) ++ dhpk(get(E_resp<j@m>))
func honest_H6_pre<i,j@n,m>(c, ts, tau) = crh(honest_H5_pre<session i,
session j, pid n, pid m>(c, ts)) ++ tau
func honest_H7_pre<i, j@n,m>(c, ts, tau, c') = 
    crh(honest_H6_pre<session i, session j, pid n, pid m>(c, ts, tau)) ++ c'


name msg1_C1 : RO[e_init] strict crh(construction()) ++ e_init -> nonce
    requires is_group_elem(e_init)
    uniqueness_by ()


counter aead_counter_msg1_C2<i@n> @ Initiator<n>

name msg1_C2<@m> : RO[e_init] strict{0} get(msg1_C1[e_init;0]) ++ dh_combine(e_init, get(S_resp<@m>)) -> nonce || 
    st_aead (exists n. dhpk(S_init<@n>))
            aad x. true // x == crh(honest_H2_pre<idx session i>())
            nonce aead_counter_msg1_C2
            nonce_pattern *
    requires is_group_elem(e_init)
    uniqueness_by { is_constant_lemma(crh(construction())) }



type Empty = (x:Data<adv>{false})

counter aead_counter_msg1_C3<i@n> @ Initiator<n>

predicate valid_init_ephemeral<n>(x) = exists i:idx. x == dhpk(get(E_init<i@n>))

name msg1_C3<@n,m> : RO[e_init] strict get(msg1_C2<@m>[e_init;0]) ++ dh_combine(dhpk(get(S_resp<@m>)), get(S_init<@n>)) -> nonce || 
    st_aead (if valid_init_ephemeral<n>[e_init] then Data<adv> |12| else Empty)
            aad x. true // (exists c:bv. x == crh(honest_H3_pre<idx session i>(c)))
            nonce aead_counter_msg1_C3
            nonce_pattern *
    requires is_group_elem(e_init)
    uniqueness_by { is_constant_lemma(crh(construction())) }

// // needs to use the crh hash function, rather than kdf
// name msg1_mac1_key<@m> : RO strict{0} mac1() ++ dhpk(get(S_resp<@m>)) -> mackey Data<adv> 
//     uniqueness_by { assume (mac1() != crh(construction())); 
//                     is_constant_lemma(crh(construction())) }

    
name msg2_C4<@n,m> : RO[e_init,e_resp] strict{0} get(msg1_C3<@n,m>[e_init;0]) ++ e_resp -> nonce
    requires is_group_elem(e_init)
    requires is_group_elem(e_resp)
    uniqueness_by { is_constant_lemma(crh(construction())) }

    

name msg2_C5<@n,m> : RO[e_init,e_resp, ss] strict{0} get(msg2_C4<@n,m>[e_init,e_resp;0]) ++ ss -> nonce
    requires is_group_elem(ss)
uniqueness_by  { 
    is_constant_lemma(crh(construction()));
    is_constant_lemma(mac1())
}




name msg2_C6<@n,m> : RO[e_init, e_resp, ss] strict{0}
get(msg2_C5<@n,m>[e_init,e_resp, ss;0]) ++ dh_combine(e_resp, get(S_init<@n>)) -> nonce
    requires is_group_elem(e_init)
    requires is_group_elem(e_resp)
    requires is_group_elem(ss)
uniqueness_by  { 
    is_constant_lemma(crh(construction()));
    is_constant_lemma(mac1())
}


counter aead_counter_msg2_C7<j@m> @ Responder<m>


predicate valid_resp_ephemeral<m>(x) = exists j:idx. x == dhpk(get(E_resp<j@m>))
        
name msg2_C7<@n,m> : RO[e_init, e_resp, ss] strict{0, 2}
get(msg2_C6<@n,m>[e_init,e_resp, ss;0]) ++ (zeros_32()) -> nonce || nonce || 
    st_aead (if (valid_resp_ephemeral<m>[e_resp]) then Data<adv> |0| else Empty)

            aad x. true // sec(S_init<@n>) /\ sec(S_resp<@m>) ==> exists c:bv, ts:bv, tau:bv. x == crh(honest_H6_pre<session i, pid n, session j, pid m>(c, ts, tau))
            nonce aead_counter_msg2_C7
            nonce_pattern *
    requires is_group_elem(e_init)
    requires is_group_elem(e_resp)
    requires is_group_elem(ss)
    uniqueness_by  { 
        is_constant_lemma(crh(construction()));
        forall e2:bv { 
            assume (
                 crh(construction()) ++ e2 != 
                        get(msg2_C6<@n,m>[e_init,e_resp, ss;0]) ++
                        (zeros_32()))
        };
        ()
        // forall n2:idx { 
        //     disjoint_not_eq_lemma(preimage(msg1_mac1_key<@n2>), get(msg2_C6<@n,m>[e_init,e_resp, ss;0]) ++ (zeros_32()))
        // }
        
    }

corr<n,m>[e_init, e_resp, ss] adv ==> [msg2_C7<@n,m>[e_init,e_resp, ss;1]]

// // needs to use the crh hash function, rather than kdf
// name msg2_mac1_key<@n> : RO mac1() ++ dhpk(get(S_init<@n>)) -> mackey Data<adv>
//     uniqueness_by { 
//         is_constant_lemma(crh(construction()));
//         forall n2:idx, m:idx, a:bv, b:bv, c:bv {
//             disjoint_not_eq_lemma(mac1() ++ dhpk(get(S_init<@n>)),
//                     preimage(msg2_C7<@n2,m>[a,b,c]))
//         };
//         assume (mac1() != crh(construction()))
//     }
            



locality dummy : 2 // TODO just for now

name channel_secret<@n,m> : nonce @ dummy<n,m>
corr<n,m> [S_init<@n>] ==> [channel_secret<@n,m>]
corr<n,m> [S_resp<@m>] ==> [channel_secret<@n,m>]

/*

type payload_i2r = Data<adv /\ [channel_secret], |adv|>
type payload_r2i = Data<adv /\ [channel_secret], |adv|>
*/

counter N_init_send<i@n> @ Initiator<n>
counter N_init_recv<i@n> @ Initiator<n>
counter N_resp_send<j@m> @ Responder<m>
counter N_resp_recv<j@m> @ Responder<m>

name transp_T<@n,m> : RO[e_init, e_resp, ss] strict get(msg2_C7<@n,m>[e_init, e_resp, ss;0]) ++ 0x -> 
    st_aead (Data<adv /\ [channel_secret<@n,m>], |adv|>)
        aad x. true
        nonce N_init_send
        nonce_pattern * ||
    st_aead (Data<adv /\ [channel_secret<@n,m>], |adv|>)
        aad x. true
        nonce N_resp_send
       nonce_pattern *
    uniqueness_by { 
        admit
    }


////////////////////////////
// Message formats

struct msg1 {
      _msg1_tag : Const(0x01000000)
    , _msg1_sender : Data<adv> |4| // bytes??
    , _msg1_ephemeral : Data<adv> | |group| |
    , _msg1_static : Data<adv> | cipherlen(|group|) | 
    , _msg1_timestamp: Data<adv> | cipherlen(12) |
    // TODO cookie mechanism
    , _msg1_mac1: Data<adv> | |maclen| |
    , _msg1_mac2: Const(0x00000000000000000000000000000000) // hardcode |maclen|=16 zeros, for now
}

struct msg2 {
      _msg2_tag : Const(0x02000000)
    , _msg2_sender: Data<adv> |4|
    , _msg2_receiver: Data<adv> |4|
    , _msg2_ephemeral: Data<adv> | |group| |
    , _msg2_empty: Data<adv> | cipherlen(0) |
    // TODO cookie mechanism
    , _msg2_mac1: Data<adv> | |maclen| |
    , _msg2_mac2: Const(0x00000000000000000000000000000000) // hardcode |maclen|=16 zeros, for now
}


struct transp {
      _transp_tag : Const(0x04000000)
    , _transp_receiver : Data<adv> |4|
    , _transp_counter  : Data<adv> | |counter| | 
    , _transp_packet   : Data<adv> 
}


////////////////////////////
// Primitives

func padding() = 0x000000
func msg1_tag_value() = 0x01000000
func msg2_tag_value() = 0x02000000
func transp_tag_value() = 0x04000000

def get_sender_i<@n>  () @ Initiator<n> : Data<adv> |4| // TODO can we model this as a nonce?
def timestamp_i<@n>   () @ Initiator<n> : Data<adv> |12|

def get_sender_r<@m>  () @ Responder<m> : Data<adv> |4| // TODO can we model this as a nonce?
def timestamp_r<@m>   () @ Responder<m> : Data<adv> |12|


////////////////////////////
// Return data

struct initiator_msg1_val<i,n,m> {
      _initiator_msg1_C3 : Name(msg1_C3<@n,m>[dhpk(get(E_init<i@n>));0])
    , _initiator_msg1_H4 : (x:Data<adv>{
        (corr(msg1_C3<@n,m>[dhpk(get(E_init<i@n>)); 0])
            ==>
            (corr(S_init<@n>) \/ corr(S_resp<@m>)))
        /\
        exists c:bv, ts:bv. x ==
    crh(honest_H4_pre<session i, pid n, pid m>(c, ts))})
}





struct transp_keys {
      _transp_keys_initiator : Data<adv> |4|  // value of get_sender_i
    , _transp_keys_responder : Data<adv> |4|  // value of get_sender_r
    , _transp_keys_init_ephemeral : Ghost  
    , _transp_keys_resp_ephemeral : Ghost  
    , _transp_keys_T_init_send : Data<top> | |enckey| |
    , _transp_keys_T_resp_send : Data<top> | |enckey| |
}


// Transport keys for talking from session i of initiator n to some session of responder m 
predicate valid_transp_keys_init<i,n,m>(s) = 
    let dh_other = _transp_keys_resp_ephemeral(s) in 
    (_transp_keys_init_ephemeral(s) == dhpk(get(E_init<i@n>)))
    /\
    is_group_elem(dh_other)
    /\
    (forall j:idx. dh_other == dhpk(get(E_resp<j@m>)) ==>
        _transp_keys_T_init_send(s) == get(transp_T<@n,m>[
            dhpk(get(E_init<i@n>)),
            dhpk(get(E_resp<j@m>)),
            dh_combine(dhpk(get(E_init<i@n>)), get(E_resp<j@m>))
            ; 0])
             /\
        _transp_keys_T_resp_send(s) == get(transp_T<@n,m>[
            dhpk(get(E_init<i@n>)),
            dhpk(get(E_resp<j@m>)),
            dh_combine(dhpk(get(E_init<i@n>)), get(E_resp<j@m>))
            ; 1]))
    /\
    ((forall j:idx. dh_other != dhpk(get(E_resp<j@m>))) ==>
        _transp_keys_T_init_send(s) == 
            get(transp_T<@n,m>[dhpk(get(E_init<i@n>)), dh_other, dh_combine(dh_other, get(E_init<i@n>));0]) /\
        _transp_keys_T_resp_send(s) == 
            get(transp_T<@n,m>[dhpk(get(E_init<i@n>)), dh_other,
            dh_combine(dh_other, get(E_init<i@n>));1]) /\
        (corr(S_init<@n>) \/ corr(S_resp<@m>)) 
    )
        
    


///////// Initiator code //////////
    

def generate_msg1<i@n,m> (dhpk_S_resp : dhpk(S_resp<@m>), ss_S_resp_S_init: shared_secret(S_init<@n>, S_resp<@m>)) @ Initiator<n> :
  initiator_msg1_val<session i, pid n, pid m> =
    let C0 = crh(construction()) in
    let H0 = crh(C0 ++ identifier()) in 
    let H1 = crh(H0 ++ dhpk_S_resp) in
    let e_init = dhpk(get(E_init<i@n>)) in 
    let C1 = hash<msg1_C1[e_init]; 0>(C0, e_init) in 
    let H2 = crh(H1 ++ e_init) in
    let ss_S_resp_E_init = dh_combine(dhpk_S_resp, get(E_init<i@n>)) in
    let C2 = hash<msg1_C2<@m>[e_init];0>(C1, ss_S_resp_E_init) in
    let k0 = hash<msg1_C2<@m>[e_init];1>(C1, ss_S_resp_E_init) in
    let msg1_static : Data<adv> |cipherlen(|group|)|
        = st_aead_enc<aead_counter_msg1_C2<i@n>>(k0, pack<n>(dhpk(get(S_init<@n>))), H2) in 
    let H3 = crh(H2 ++ msg1_static) in
    // let ss_S_resp_S_init = dh_combine(dhpk_S_resp, get(S_init<@n>)) in
    let C3 = hash<msg1_C3<@n,m>[e_init];0>(C2, ss_S_resp_S_init) in
    let k1 = hash<msg1_C3<@n,m>[e_init];1>(C2, ss_S_resp_S_init) in
    let timestamp = call timestamp_i<@n>() in
    let msg1_timestamp : Data<adv> |cipherlen(12)| =
        st_aead_enc<aead_counter_msg1_C3<i@n>>(k1, timestamp, H3) in 
    let H4 = crh(H3 ++ msg1_timestamp) in

    let msg1_sender : Data<adv> |4| = call get_sender_i<@n>() in
    let msg1_tag = msg1_tag_value() in 

    // let msg1_mac1_k = hash<msg1_mac1_key<@m>>(mac1(), dhpk_S_resp) in 
    let msg1_mac1_k = crh(mac1() ++ dhpk_S_resp) in 
    let msg1_mac1 = mac(msg1_mac1_k, 
        msg1_tag ++ msg1_sender ++ e_init ++ msg1_static ++ msg1_timestamp) in
    assume(length(msg1_mac1) == |maclen|);
    let msg1_mac2 = zeros_16() in
    let msg1_output: msg1 = msg1(msg1_tag, msg1_sender, e_init, msg1_static, msg1_timestamp, msg1_mac1, msg1_mac2) in
    // let msg1_output = msg1(msg1_payload_value) in
    let _ = output msg1_output to endpoint(Responder<m>) in // TODO: does it make sense to index the responder?
    let retval = initiator_msg1_val<session i, pid n, pid m>(C3, H4) in
    retval

def receive_msg2<i@n,m> (msg1_val: initiator_msg1_val<session i, pid n, pid m>, dhpk_S_resp : dhpk(S_resp<@m>)) @ Initiator<n>
    : Option ((x:transp_keys{valid_transp_keys_init<i,n,m>[x]})) =
    // set_option ":rlimit" "2000000" in 
    input inp in
    parse inp as msg2(msg2_tag, msg2_sender, msg2_receiver, msg2_ephemeral', msg2_empty, msg2_mac1, msg2_mac2) in {
    parse msg1_val as initiator_msg1_val<idx i, idx n, idx m>(C3, H4) in {

    guard andb(eq(length(msg2_sender), 4), eq(length(msg2_receiver), 4)) in
    guard is_group_elem(msg2_ephemeral') in 

    let psk = zeros_32() in 

    pcase (exists j:idx. msg2_ephemeral' == dhpk(get(E_resp<j@m>))) in
    choose_idx j | msg2_ephemeral' == dhpk(get(E_resp<j@m>)) in
    let msg2_ephemeral : if (msg2_ephemeral' == dhpk(get(E_resp<j@m>))) then dhpk(E_resp<j@m>) else 
        (x:Data<adv> {x == msg2_ephemeral'}) = msg2_ephemeral' in 
    let e_init = get(E_init<i@n>) in 
    let e_init_pk = dhpk(e_init) in
    let C4 = hash<msg2_C4<@n,m>[e_init_pk, msg2_ephemeral]>(C3, msg2_ephemeral) in
    let H5 = crh(H4 ++ msg2_ephemeral) in
    let ss = dh_combine(msg2_ephemeral, e_init) in 
    let C5 = hash<msg2_C5<@n,m>[e_init_pk, msg2_ephemeral, ss]>(C4, ss) in
    let C6 = hash<msg2_C6<@n,m>[e_init_pk, msg2_ephemeral, ss]>(C5, dh_combine(msg2_ephemeral, get(S_init<@n>))) in
    let C7 = hash<msg2_C7<@n,m>[e_init_pk, msg2_ephemeral, ss]>(C6, psk) in
    let tau = hash<msg2_C7<@n,m>[e_init_pk, msg2_ephemeral, ss]; 1>(C6, psk) in
    let k0 = hash<msg2_C7<@n,m>[e_init_pk, msg2_ephemeral, ss]; 2>(C6, psk) in
    let H6 : Data<adv> = crh(H5 ++ tau) in
    let emptystring = 0x in 
    
    corr_case msg2_C7<@n,m>[e_init_pk, msg2_ephemeral, ss;2] in
    case st_aead_dec(k0, msg2_empty, H6, 0x) {
    | None => None<ty: x:transp_keys{valid_transp_keys_init<i,n,m>[x]}>()
    | Some msg2_empty_dec => 
        false_elim in
        guard eq(msg2_empty_dec, emptystring) in 
        let H7 = crh(H6 ++ msg2_empty) in
        // Calculate transport keys
        let T_init_send = hash<transp_T<@n,m>[e_init_pk, msg2_ephemeral, ss]; 0>(C7, 0x) in
        let T_init_recv = hash<transp_T<@n,m>[e_init_pk, msg2_ephemeral, ss]; 1>(C7, 0x) in
        let retval = transp_keys(msg2_receiver, msg2_sender, dhpk(e_init), msg2_ephemeral, T_init_send, T_init_recv) in
        assert(valid_transp_keys_init<i,n,m>[retval]);
        Some(retval)
    }
    }
    } otherwise None<ty: x:transp_keys{valid_transp_keys_init<i,n,m>[x]}>()

///////// Responder code //////////


struct responder_msg1_val {
      _responder_msg1_C3 : Data<top> | |nonce| | 
    , _responder_msg1_H4 : Data<adv> | |crh| |
    , _responder_msg1_ephemeral : Data<adv> | |group| |
    , _responder_msg1_sender_pk : Data<adv> | |group| |
    , _responder_msg1_sender : Data<adv> |4|
}


predicate valid_h4<i,n,m>(x) = 
    exists c:bv, ts:bv. x == crh(honest_H4_pre<session i, pid n, pid m>(c, ts))

predicate valid_responder_msg1_val<n,m> (s) = 
    let eph = _responder_msg1_ephemeral(s) in 
    let h4 = _responder_msg1_H4(s) in 
    let c3 = _responder_msg1_C3(s) in
    is_group_elem(eph)  
    /\ (_responder_msg1_sender_pk(s) == dhpk(get(S_init<@n>)))
    /\ (forall i:idx. eph == dhpk(get(E_init<i@n>)) ==> 
        c3 == get(msg1_C3<@n,m>[dhpk(get(E_init<i@n>));0])
        /\ (sec(msg1_C3<@n,m>[dhpk(get(E_init<i@n>));0]) <==> 
             sec(msg1_C3<@n,m>[dhpk(get(E_init<i@n>));1]))
        /\ valid_h4<i,n,m>[h4])
    /\ ((forall i:idx. eph != dhpk(get(E_init<i@n>))) ==> 
        c3 == get(msg1_C3<@n,m>[eph;0]) 
        /\ corr(msg1_C3<@n,m>[eph;0])
        /\ (corr(S_init<@n>) \/ corr(S_resp<@m>))
        )



predicate valid_transp_keys_resp<j,n,m>(s) = 
    let dh_other = _transp_keys_init_ephemeral(s) in 
    (_transp_keys_resp_ephemeral(s) == dhpk(get(E_resp<j@m>)))
    /\
    is_group_elem(dh_other)
    /\
    (forall i:idx. dh_other == dhpk(get(E_init<i@n>)) ==>
        _transp_keys_T_init_send(s) == get(transp_T<@n,m>[
            dhpk(get(E_init<i@n>)),
            dhpk(get(E_resp<j@m>)),
            dh_combine(dhpk(get(E_init<i@n>)), get(E_resp<j@m>))
        ;0]) /\
        _transp_keys_T_resp_send(s) == get(transp_T<@n,m>[
            dhpk(get(E_init<i@n>)),
            dhpk(get(E_resp<j@m>)),
            dh_combine(dhpk(get(E_init<i@n>)), get(E_resp<j@m>))
        ;1])) 
    /\
    ((forall i:idx. dh_other != dhpk(get(E_init<i@n>))) ==>
        _transp_keys_T_init_send(s) == get(transp_T<@n,m>[
            dh_other,
            dhpk(get(E_resp<j@m>)),
            dh_combine(dh_other, get(E_resp<j@m>))
        ;0]) /\
        _transp_keys_T_resp_send(s) == get(transp_T<@n,m>[
            dh_other,
            dhpk(get(E_resp<j@m>)),
            dh_combine(dh_other, get(E_resp<j@m>))
        ;1]) /\
        (corr(S_init<@n>) \/ corr(S_resp<@m>))
    )

def checkpk_resp<@m>(pk : Data<adv>) @ Responder<m>
    : Option (exists n. (x:shared_secret(S_init<@n>, S_resp<@m>){dhpk(get(S_init<@n>)) == pk}))

def receive_msg1<j@m> () @ Responder<m>
     : Option (exists n. x:responder_msg1_val{valid_responder_msg1_val<n,m>[x]}) 
     =
     set_option ":rlimit" "2000000" in 
     input inp in
     parse inp as msg1(msg1_tag, msg1_sender, msg1_ephemeral', msg1_static, msg1_timestamp, msg1_mac1, msg1_mac2) in {
     guard eq(length(msg1_sender), 4) in 
     guard is_group_elem(msg1_ephemeral') in 
     let C0 = crh(construction()) in
     let H0 = crh(C0 ++ identifier()) in 
     let H1 = crh(H0 ++ dhpk(get(S_resp<@m>))) in
     pcase (exists n2:idx, i:idx. msg1_ephemeral' == dhpk(get(E_init<i@n2>))) in
     choose_idx n2 | exists i:idx. msg1_ephemeral' == dhpk(get(E_init<i@n2>)) in 
     choose_idx i | msg1_ephemeral' == dhpk(get(E_init<i@n2>)) in
     let msg1_ephemeral : if (msg1_ephemeral' == dhpk(get(E_init<i@n2>))) then
     dhpk(E_init<i@n2>) else (x:Data<adv>{x == msg1_ephemeral'}) = msg1_ephemeral' in
     let C1 = hash<msg1_C1[msg1_ephemeral]>(C0, msg1_ephemeral) in 
     let H2 = crh(H1 ++ msg1_ephemeral) in
     let ss_msg1_ephemeral_S_resp = dh_combine(msg1_ephemeral, get(S_resp<@m>)) in
     let C2 = hash<msg1_C2<@m>[msg1_ephemeral];0>(C1, ss_msg1_ephemeral_S_resp) in
     let k0 = hash<msg1_C2<@m>[msg1_ephemeral];1>(C1, ss_msg1_ephemeral_S_resp) in
     corr_case msg1_C2<@m>[msg1_ephemeral;1] in
     case st_aead_dec(k0, msg1_static, H2, 0x) {
         | None => None<ty:(exists n. x:responder_msg1_val{valid_responder_msg1_val<n,m>[x]})>()
         | Some msg1_static_dec => 
                false_elim in
                let opk = call checkpk_resp<@m>(msg1_static_dec) in
                case opk {
                    | None => None<ty:(exists n. x:responder_msg1_val{valid_responder_msg1_val<n,m>[x]})>()
                    | Some ss_S_init_S_resp_ =>
                        unpack n, ss_S_init_S_resp = ss_S_init_S_resp_ in 
                        let dhpk_S_init : dhpk(S_init<@n>) = msg1_static_dec in
                        // guard eq(msg1_static_dec, dhpk_S_init) in // Not needed since we have the refinement on ss_S_init_S_resp
                        let H3 = crh(H2 ++ msg1_static) in
                        let C3 = hash<msg1_C3<@n,m>[msg1_ephemeral];0>(C2, ss_S_init_S_resp) in
                        let k1 = hash<msg1_C3<@n,m>[msg1_ephemeral];1>(C2, ss_S_init_S_resp) in
                        corr_case msg1_C3<@n,m>[msg1_ephemeral;1] in
                        case st_aead_dec(k1, msg1_timestamp, H3, 0x) {
                        | None => None<ty:(exists n. x:responder_msg1_val{valid_responder_msg1_val<n,m>[x]})>()
                        | Some msg1_timestamp_dec =>
                            false_elim in 
                            let H4 = crh(H3 ++ msg1_timestamp) in
                            let retval : x:responder_msg1_val{valid_responder_msg1_val<n,m>[x]} = 
                                responder_msg1_val(C3, H4, msg1_ephemeral, dhpk_S_init, msg1_sender) in
                            let v : exists n. x:responder_msg1_val{valid_responder_msg1_val<n,m>[x]} = pack<n>(retval) in 
                            Some(v)
                        }
                }
     }
     } otherwise  None<ty:(exists n. x:responder_msg1_val{valid_responder_msg1_val<n,m>[x]})>()
    

def generate_msg2<j@m> (msg1_val':
exists n. (x:responder_msg1_val{valid_responder_msg1_val<n,m>[x]})) @ Responder<m>
    : exists n. s:transp_keys {valid_transp_keys_resp<j,n,m>[s]}
    =
    unpack n, msg1_val = msg1_val' in
    parse msg1_val as responder_msg1_val(C3, H4, ephemeral', dhpk_S_init, msg2_receiver) in {
    pcase ((exists i:idx. ephemeral' == dhpk(get(E_init<i@n>)))) in 
    choose_idx i | ephemeral' == dhpk(get(E_init<i@n>)) in
    let ephemeral : if (ephemeral' == dhpk(get(E_init<i@n>))) then dhpk(E_init<i@n>) else (x:Data<adv>{x == ephemeral'}) = ephemeral' in 
    let e_resp_pk = dhpk(get(E_resp<j@m>)) in 
    let psk = zeros_32() in 
    let C4 = hash<msg2_C4<@n,m>[ephemeral, e_resp_pk]>(C3, e_resp_pk) in
    let H5 = crh(H4 ++ e_resp_pk) in
    let ss = dh_combine(ephemeral, get(E_resp<j@m>)) in 
    let C5 = hash<msg2_C5<@n,m>[ephemeral, e_resp_pk, ss]>(C4, ss) in
    let C6 = hash<msg2_C6<@n,m>[ephemeral, e_resp_pk, ss]>(C5, dh_combine(dhpk_S_init, get(E_resp<j@m>))) in
    let C7 = hash<msg2_C7<@n,m>[ephemeral, e_resp_pk, ss];0>(C6, psk) in
    let tau = hash<msg2_C7<@n,m>[ephemeral, e_resp_pk, ss];1>(C6, psk) in
    let k0 = hash<msg2_C7<@n,m>[ephemeral, e_resp_pk, ss];2>(C6, psk) in
    let H6 = crh(H5 ++ tau) in
    let emptystring = 0x in
    let msg2_empty = st_aead_enc<aead_counter_msg2_C7<j@m>>(k0, emptystring, H6) in
    let H7 = crh(H6 ++ msg2_empty) in
    let msg2_sender : Data<adv> |4| = call get_sender_r<@m>() in
    let msg2_tag = msg2_tag_value() in 
    // let msg2_mac1_k = hash<msg2_mac1_key<@n>>(mac1(), dhpk_S_init) in
    let msg2_mac1_k = crh(mac1() ++ dhpk_S_init) in
    let msg2_mac1 = mac(msg2_mac1_k,
        msg2_tag ++ msg2_sender ++ msg2_receiver ++ e_resp_pk ++
        msg2_empty) in 
    assume(length(msg2_mac1) == |maclen|);
    let msg2_mac2 = zeros_16() in
    let msg2_output: msg2 = msg2(
        msg2_tag, msg2_sender, msg2_receiver, e_resp_pk, msg2_empty, msg2_mac1, msg2_mac2
    ) in
    // let msg2_output = msg2(msg2_payload_value) in
    let _ = output msg2_output /* to endpoint(Initiator<n>) */ in // (TODO: endpoint? )
    
    // Calculate transport keys
    let T_resp_recv = hash<transp_T<@n,m>[ephemeral, e_resp_pk, ss]; 0>(C7, 0x) in
    let T_resp_send = hash<transp_T<@n,m>[ephemeral, e_resp_pk, ss]; 1>(C7, 0x) in
    let retval : 
         s:transp_keys {valid_transp_keys_resp<j,n,m>[s]}
        = transp_keys(msg2_receiver, msg2_sender, ephemeral, e_resp_pk, T_resp_recv, T_resp_send) in
    // assert valid_transp_keys_resp<j,n,m>[retval];
    pack<n>(retval)
    }


//// Transport layer messages ////



def transp_send_init<i@n,m> (transp_keys_val :
(x:transp_keys{valid_transp_keys_init<i,n,m>[x]}), plaintext : Data<adv /\ [channel_secret<@n,m>], |adv|>) @ Initiator<n>
    : Option(Unit) = 
    parse transp_keys_val as transp_keys(_, transp_receiver, _, eph_resp, i2r', _) in { 
    pcase (exists j:idx. eph_resp == dhpk(get(E_resp<j@m>))) in 
    choose_idx j | eph_resp == dhpk(get(E_resp<j@m>)) in
    let i2r : 
    Name(transp_T<@n,m>[dhpk(get(E_init<i@n>)), eph_resp, dh_combine(eph_resp, get(E_init<i@n>)); 0])
        =  i2r' in
    let transp_counter = get_counter N_init_send<i@n> in

    // let transp_receiver = _transp_keys_responder(transp_keys_val) in
    let transp_tag = transp_tag_value() in 
    guard eq(length(transp_receiver), 4) in 

    let transp_packet = st_aead_enc<N_init_send<i@n>>(i2r, plaintext, 0x) in

    let transp_output = transp(transp_tag, transp_receiver, transp_counter, transp_packet) in
    // let transp_output = transp(transp_payload_value) in
    let _ = output transp_output to endpoint(Responder<m>) in
    Some(())
    }

predicate init_recv_secure_inner<i,j,n,m>(k) = 
    let e_init = get(E_init<i@n>) in
    let e_resp = get(E_resp<j@m>) in
    (_transp_keys_T_resp_send(k) == get(
    transp_T<@n,m>[
        dhpk(e_init),
        dhpk(e_resp),
        dh_combine(dhpk(e_init), e_resp); 1])
     /\
     sec(
        transp_T<@n,m>[
            dhpk(e_init),
            dhpk(e_resp),
            dh_combine(dhpk(e_init), e_resp); 1]))
    
predicate init_recv_secure<i,n,m>(k) = 
    exists j:idx. init_recv_secure_inner<i,j,n,m>[k]

def transp_recv_init<i@n,m> (transp_keys_val :
(x:transp_keys{valid_transp_keys_init<i,n,m>[x]}), c : Data<adv>) @ Initiator<n> :   
    Option(if init_recv_secure<i,n,m>[transp_keys_val] then Data<adv /\ [channel_secret<@n,m>], |adv|> else Data<adv>)
    = 
    parse c as transp(_, from, ctr, pkt) in {
    parse transp_keys_val as transp_keys(_, responder_name, _, eph_resp, _, r2i') in {
    guard eq(c, responder_name) in 
    pcase (exists j:idx. eph_resp == dhpk(get(E_resp<j@m>))) in 
    choose_idx j | eph_resp == dhpk(get(E_resp<j@m>)) in
    let r2i : 
     Name(transp_T<@n,m>[dhpk(get(E_init<i@n>)), eph_resp, dh_combine(eph_resp, get(E_init<i@n>));1])
       =  r2i' in       
    corr_case transp_T<@n,m>[dhpk(get(E_init<i@n>)), eph_resp, dh_combine(eph_resp, get(E_init<i@n>)) ;1] in 
    // Below to instantiate quantifier
    assert ((sec(transp_T<@n,m>[dhpk(get(E_init<i@n>)), eph_resp, dh_combine(eph_resp, get(E_init<i@n>)) ;1]) /\ eph_resp == dhpk(get(E_resp<j@m>))) ==> 
    init_recv_secure_inner<i,j,n,m>[transp_keys_val]);

    st_aead_dec(r2i, pkt, 0x, ctr)
    }
    } otherwise None<ty: if init_recv_secure<i,n,m>[transp_keys_val] then Data<adv /\ [channel_secret<@n,m>], |adv|> else Data<adv>>()
    

def transp_send_resp<j@n,m> (transp_keys_val :
(x:transp_keys{valid_transp_keys_resp<j,n,m>[x]}), plaintext : Data<adv /\
[channel_secret<@n,m>], |adv|>) @ Responder<m>
    : Option(Unit) = 
    
    parse transp_keys_val as transp_keys(transp_receiver, _, eph_init, _, _, r2i') in {
    pcase (exists i:idx. eph_init == dhpk(get(E_init<i@n>))) in 
    choose_idx i | eph_init == dhpk(get(E_init<i@n>)) in
    let r2i : 
    Name(transp_T<@n,m>[eph_init, dhpk(get(E_resp<j@m>)), dh_combine(eph_init,
    get(E_resp<j@m>)); 1])
       =  r2i' in       
    let transp_counter = get_counter N_resp_send<j@m> in

    let transp_tag = transp_tag_value() in 
    guard eq(length(transp_receiver), 4) in 

    let transp_packet = st_aead_enc<N_resp_send<j@m>>(r2i, plaintext, 0x) in

    let transp_output = 
        transp(transp_tag, transp_receiver, transp_counter, transp_packet) in
    // let transp_output = transp(transp_payload_value) in
    let _ = output transp_output to endpoint(Initiator<n>) in
    Some(())
    }


predicate resp_recv_secure_inner<i,j,n,m>(k) = 
    let e_init = get(E_init<i@n>) in
    let e_resp = get(E_resp<j@m>) in
    (_transp_keys_T_init_send(k) == get(
    transp_T<@n,m>[
        dhpk(e_init),
        dhpk(e_resp),
        dh_combine(dhpk(e_init), e_resp); 0])
     /\
     sec(
        transp_T<@n,m>[
            dhpk(e_init),
            dhpk(e_resp),
            dh_combine(dhpk(e_init), e_resp); 0]))
    
predicate resp_recv_secure<j,n,m>(k) = 
    exists i:idx. resp_recv_secure_inner<i,j,n,m>[k]

def transp_recv_resp<j@n,m> (transp_keys_val :
(x:transp_keys{valid_transp_keys_resp<j,n,m>[x]}), c : Data<adv>) @ Responder<m> :   
    Option(if resp_recv_secure<j,n,m>[transp_keys_val] then Data<adv /\ [channel_secret<@n,m>], |adv|> else Data<adv>)
    = 
    parse c as transp(_, from, ctr, pkt) in {
    parse transp_keys_val as transp_keys(initiator_name, _, eph_init, _, i2r', _) in {
    guard eq(c, initiator_name) in 
    pcase (exists i:idx. eph_init == dhpk(get(E_init<i@n>))) in 
    choose_idx i | eph_init == dhpk(get(E_init<i@n>)) in
    let i2r : 
     Name(transp_T<@n,m>[eph_init, dhpk(get(E_resp<j@m>)), dh_combine(eph_init, get(E_resp<j@m>));0])
       =  i2r' in       
    corr_case transp_T<@n,m>[eph_init, dhpk(get(E_resp<j@m>)),
    dh_combine(eph_init, get(E_resp<j@m>)) ;0] in 
    // Below to instantiate quantifier
    assert ((sec(transp_T<@n,m>[eph_init, dhpk(get(E_resp<j@m>)),
    dh_combine(eph_init, get(E_resp<j@m>)) ;0]) /\ eph_init == dhpk(get(E_init<i@n>))) ==>
        resp_recv_secure_inner<i,j,n,m>[transp_keys_val]);

    st_aead_dec(i2r, pkt, 0x, ctr)
    }
    } otherwise None<ty: if resp_recv_secure<j,n,m>[transp_keys_val] then Data<adv /\ [channel_secret<@n,m>], |adv|> else Data<adv>>()





///////// Main functions //////////
// TODO these can be removed once extraction stops demanding them

def Initiator_main<@n>() @ Initiator<n> : Unit = ()
def Responder_main<@n>() @ Responder<n> : Unit = ()
def dummy_main<@n,m>() @ dummy<n,m> : Unit = ()
